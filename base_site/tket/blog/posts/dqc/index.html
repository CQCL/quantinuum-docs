<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../genindex/" /><link rel="search" title="Search" href="../../search/" />

    <!-- Generated with Sphinx 8.2.1 and Furo 2024.08.06 -->
        <title>Optimisation of Distributed Quantum Circuits - TKET Developer Blog</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=edea75bb" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style>
<link rel="stylesheet" href="../../_static/tokens.css"/>
<link rel="stylesheet" href="../../_static/styles.css"/>
<link rel="stylesheet" href="../../_static/tailwind.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="preload"
as="style">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">

<style>  
  .sidebar-sticky {
    top: calc(3.5rem - 0px);
    height: calc(100vh - 3.5rem);
  }
  
  @media (min-width: 97em) {
    html {
      font-size: 100% !important;
    }
  }
  
</style>
</head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>
<!-- <script type="text/javascript" src="../../_static/syncTheme.global.js" ></script> -->
 <!--Force light mode -->
 <script>document.body.setAttribute('data-theme','light')</script>
<nav style="position:fixed;top:0;z-index:1021;width:100%;">
    <div class="nexus-nav"></div>
</nav>
<script type="text/javascript" src="../../_static/injectNav.global.js"></script>
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../"><div class="brand">TKET Developer Blog</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky">
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          

<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="optimisation-of-distributed-quantum-circuits">
<h1>Optimisation of Distributed Quantum Circuits<a class="headerlink" href="#optimisation-of-distributed-quantum-circuits" title="Link to this heading">¶</a></h1>
<p>As quantum computers scale up, their basic components grow farther apart, increasing the challenge of driving accurate interactions between them. Distributed quantum computing proposes a strategy that focuses on separation of concerns: first, engineer a quantum computer that performs reliably on the limited number of qubit it can manage and, then, produce multiple copies of it and connect them together to create larger devices. This strategy establishes two abstract levels of qubit interactions: within a single quantum computing module and between different modules. An efficient quantum circuit would use as few of the latter inter-module qubit interactions as possible, since those will be the main bottleneck of the computation.</p>
<p>From a user’s perspective, however, it is desirable to think of an architecture with <span class="math notranslate nohighlight">\(k\)</span> quantum modules of <span class="math notranslate nohighlight">\(n\)</span> qubits each as a large monolithic quantum computer of <span class="math notranslate nohighlight">\(kn\)</span> qubits. It is then the task of the quantum compiler to convert the user’s circuit into an equivalent one comprised of <span class="math notranslate nohighlight">\(k\)</span> different subcircuits – each of at most <span class="math notranslate nohighlight">\(n\)</span> qubits – orchestrated together in such a way that the quantum interactions between modules are minimised. This blogpost discusses approaches for the automatisation of such a task, which resulted from a research project in collaboration between Quantinuum and Mio Murao’s group from the University of Tokyo. For a more detailed discussion, please refer to the two papers we wrote on the subject [<a class="reference internal" href="#references"><span class="xref myst">1</span></a>] and [<a class="reference internal" href="#references"><span class="xref myst">2</span></a>]. The code implementing these approaches is available as a <a class="reference external" href="https://github.com/CQCL/pytket-dqc">pytket extension</a>. A Jupyter notebook showcasing its basic usage can be found <a class="reference external" href="https://github.com/CQCL/pytket-dqc/blob/main/examples/basic_usage.ipynb">here</a>.</p>
<p>In our framework, we assume that the bottleneck of the computation is at the interaction between modules, and that the cost of computation within a module is comparatively “free”. Consequently, we do not attempt to optimise the layout of the subcircuits. Of course, once the circuit is distributed efficiently, the next stage of optimisation would be to apply standard optimisation passes on each of the subcircuits to further optimise the internal execution in each module. Such passes are available in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> (see the <a class="reference internal" href="#../user-guide/manual/manual_compiler.html"><span class="xref myst">manual</span></a>), including rebasing the circuit to the hardware’s native gateset, qubit routing [<a class="reference internal" href="#references"><span class="xref myst">5</span></a>] and overall circuit optimisation.</p>
<p><img alt="Schematic of how DQC fits in a compilation workflow" src="../../_images/dqc_schematic.png" /></p>
<p>We only allow quantum interactions between different modules in the form of shared Bell states. In particular, we make use of the following Bell state</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\ket{\Phi^+} = \frac{1}{\sqrt{2}} \ket{00} + \frac{1}{\sqrt{2}} \ket{11}.\]</div>
</div>
<p>Protocols such as quantum teleportation use these states as a resource to communicate quantum information between spatially separated parties. The metric we wish to minimise in our optimisation task is the number of Bell states required to execute the resulting distributed circuit. Our framework is agnostic in regards to how these Bell states are generated: they may be generated by an external device and shared between the quantum computing modules, it may be that each quantum module generates Bell states internally and shuttles one of the qubits to another module, or it may even be that Bell states are not actually realised physically, but instead simulated via sampling and classical postprocessing using circuit-knitting techniques [<a class="reference internal" href="#references"><span class="xref myst">4</span></a>].</p>
<p>The problem of optimising a distributed quantum circuit can be split into two subproblems. The first one is <em>qubit allocation</em>, where we decide which quantum computing module holds each qubit. Notice that, once qubits are allocated, some of the gates in the circuit may act on qubits located in different modules – we refer to these as <em>non-local gates</em>. The second subproblem requires us to decide how each of these non-local gates will be implemented via the consumption of Bell states. A simple solution to the qubit allocation problem is to partition the circuit in such a way that the number of non-local gates is minimised; this can be achieved by applying standard graph partitioning algorithms to the connectivity graph of the circuit. We can obtain better qubit allocations if we take into account subtleties on how the non-local gates may be implemented, as discussed in our paper [<a class="reference internal" href="#references"><span class="xref myst">2</span></a>] and other works from the literature [<a class="reference internal" href="#references"><span class="xref myst">3</span></a>]. For the sake of simplicity, in this blogpost we assume qubit allocation is solved via the simple graph partitioning approach, so that we can move on to the more intriguing aspects of non-local gate implementation.</p>
<p>The circuits that we will discuss here will be comprised of gates in the following universal gateset:</p>
<p><img alt="Notation of gates" src="../../_images/gates.png" /></p>
<p>We will refer to the different quantum computing modules using upper case letters <span class="math notranslate nohighlight">\(A, B, ...\)</span> and draw circuit diagrams with curly brackets to indicate that the selected qubits are all allocated to the specified module.</p>
<section id="multi-gate-teleportation-and-embedding">
<h2>Multi-gate teleportation and embedding<a class="headerlink" href="#multi-gate-teleportation-and-embedding" title="Link to this heading">¶</a></h2>
<p>We expect most readers will be familiar with the standard quantum teleportation protocol, where an arbitrary qubit is sent from one party to another by consuming a previously shared Bell state, along with some extra classical communication. Similarly, we can devise a gate teleportation protocol, where a single Bell state is consumed to apply a gate to a remote qubit, without changing the party that originally held the qubit. Interestingly, we can push gate teleportation further and use a single Bell state to apply multiple gates acting on the same remote qubit. For this to be possible, each of the gates must share certain property formalised in [<a class="reference internal" href="#references"><span class="xref myst">1</span></a>]. In practical terms, multi-gate teleportation is possible whenever each of the gates being teleported are controlled gates, with the remote qubit acting as their control. The circuit diagram below shows how this can be achieved.</p>
<p><img alt="The multi-gate teleportation protocol" src="../../_images/ejpp.png" /></p>
<p>The wavy line within the gray box labelled “starting process” represents a Bell state shared between modules <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. All of the quantum gates in the second circuit are local, i.e. they act on qubits located in the same module. The rightmost diagram depicts our shorthand notation for the “starting process” and “ending process” as wavy arrows. We refer to the collection of non-local gates implemented by a single multi-gate teleportation protocol as a <em>distributable packet</em>, or packet for short.</p>
<p>On its simplest form, the multi-gate teleportation protocol requires that there are no additional gates between the starting process and ending process. A straightforward generalisation of this is to allow single-qubit <span class="math notranslate nohighlight">\(Rz\)</span> rotations acting on the remote qubit <span class="math notranslate nohighlight">\(\hat{q}\)</span>, since these commute with the controlled gates and can safely be applied before or after the multi-gate teleportation protocol. More interestingly, if there are <span class="math notranslate nohighlight">\(CZ\)</span> gates sandwiched between Hadamard gates, a multi-gate teleportation protocol can still be realised, at the cost of adding extra gates as shown in the diagram below.</p>
<p><img alt="Basic example of embedding" src="../../_images/embedding.png" /></p>
<p>We refer to the additional <span class="math notranslate nohighlight">\(CZ\)</span> gate labelled <span class="math notranslate nohighlight">\(x'\)</span> above as a <em>correction gate</em>. Notice that the correction gate <span class="math notranslate nohighlight">\(x'\)</span> acts on qubits that live in the same module <span class="math notranslate nohighlight">\(B\)</span>, so the gate is local and it can readily be implemented in <span class="math notranslate nohighlight">\(B\)</span>. We then say that the gate <span class="math notranslate nohighlight">\(x\)</span> has been <em>embedded</em> within the multi-gate teleportation protocol. Notice that <span class="math notranslate nohighlight">\(x\)</span> itself is a non-local gate and a separate gate teleportation is required to implement it.</p>
<p>We can now sketch the core of our non-local gate implementation approach. First, we scan the circuit and detect all distributable packets – that is, groups of contiguous non-local gates acting on the same qubit. We then check which of these packets are separated by a sequence of embeddable gates and, when possible, merge them together into a single distributable packet – again, implementable consuming just one Bell state. At the end of this process, each non-local gate in the circuit will be present in two packets: one for each of its two qubits. Realising either of the two packets via the multi-gate teleportation protocol would result in the non-local gate being implemented and, hence, the problem becomes a matter of selecting a subset of packets that, in conjunction, contain all of the non-local gates in the circuit. This can be represented and solved as a vertex covering problem on a graph where the vertices are packets and the edges are non-local gates. However, there is a caveat which can make our solution invalid, as discussed in the next section.</p>
<section id="embedding-conflicts">
<h3>Embedding conflicts<a class="headerlink" href="#embedding-conflicts" title="Link to this heading">¶</a></h3>
<p>Assume we wish to realise two different distributable packets, each with a separate instance of the multi-gate teleportation protocol. All of the gates in one packet have their remote qubit in module <span class="math notranslate nohighlight">\(A\)</span>, and the other packet has its remote qubit in module <span class="math notranslate nohighlight">\(B\)</span>. Furthermore, assume both of these packets contain some common embedded gate <span class="math notranslate nohighlight">\(x\)</span>, as shown in figure (a) below.</p>
<p><img alt="Example of an embedding conflict" src="../../_images/conflict.png" /></p>
<p>In figure (b) we show how distributing the packet with remote qubit in <span class="math notranslate nohighlight">\(A\)</span> would cause a correction gate <span class="math notranslate nohighlight">\(y\)</span> to appear, due to the embedding of <span class="math notranslate nohighlight">\(x\)</span>. Figure (c) shows the resulting equivalent circuit if we attempt to also distribute the other packet. The correction gate <span class="math notranslate nohighlight">\(y'\)</span> necessary to embed <span class="math notranslate nohighlight">\(y\)</span> turns out to be a non-local gate! This defeats the purpose of embedding, since the Bell state we saved from joining packets via embedding must now be spent on implementing a new non-local gate <span class="math notranslate nohighlight">\(y'\)</span>.</p>
<p>To avoid this situation, we can scan the packets selected by the vertex cover approach discussed above and detect when an embedding conflict would appear. For each conflict detected we must choose which of the two distributable packets will embed the offending gate. Since no two packets can embed the same gate, the other distributable packet must be split back into two separate packets, each to be realised by a different multi-gate teleportation protocol. The choice of which packets to split to solve all embedding conflicts is not immediately obvious but, fortunately, we can identify them automatically by solving another vertex covering problem on a slightly different graph, where now the edges represent conflicts between packets. The details can be found in [<a class="reference internal" href="#references"><span class="xref myst">1</span></a>]. Once this process is finished, we have reached a valid implementation of the non-local gates in the circuit, making use of the multi-gate teleportation protocol and embedding to reduce the number of Bell states that are required.</p>
</section>
</section>
<section id="heterogeneous-networks-of-modules">
<h2>Heterogeneous networks of modules<a class="headerlink" href="#heterogeneous-networks-of-modules" title="Link to this heading">¶</a></h2>
<p>So far we have not given any thought to the topology of the network connecting the quantum computing modules. We can expect that the spatial layout of the modules may influence the connectivity between them, since creating Bell states between spatially adjacent modules might be easier.</p>
<p>In this project, we chose not to make any assumptions on the inter-connectivity of the different quantum computing modules and, instead, ask the user to model their network topology as a graph. Given such a graph – where vertices are modules and edges are direct connections between them – a new optimisation opportunity arises. For instance, in figure (b) below, the path between module <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(C\)</span> is of length two and, consequently, in order to implement the <span class="math notranslate nohighlight">\(\beta\)</span> gate we will need to consume two Bell states; fortunately, in doing so, the intermediate connection between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> can be used to implement the <span class="math notranslate nohighlight">\(\alpha\)</span> gate without any extra cost!</p>
<p><img alt="Distribution using a Steiner tree" src="../../_images/steiner.png" /></p>
<p>Figure (c) above shows another case where we can save some Bell states by “reusing” common connections in the communication paths: module <span class="math notranslate nohighlight">\(A\)</span> needs to share some entanglement with both <span class="math notranslate nohighlight">\(B\)</span> and with <span class="math notranslate nohighlight">\(C\)</span>; since they are both at distance two, we would naively need four Bell states, but we can save one by reusing the entanglement between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(D\)</span> for both paths. The task of finding efficient paths from one vertex of a graph (e.g. module <span class="math notranslate nohighlight">\(A\)</span>) to a collection of other vertices (e.g. modules <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>) using common edges as much as possible, so that the total number of edges (Bell states consumed) is minimised, is known in computer science as the Steiner tree problem. Being a well-studied problem, we can apply standard algorithms to find efficient solutions so that, so far, our workflow looks as follows:</p>
<ol class="arabic simple">
<li><p>Decide qubit allocation, either via simple graph partitioning or some more subtle approach such as in [<a class="reference internal" href="#references"><span class="xref myst">2</span></a>] or [<a class="reference internal" href="#references"><span class="xref myst">3</span></a>].</p></li>
<li><p>Scan the circuit for distributable packets and embedding opportunities; using vertex covering indentify an efficient subset of these packets and embeddings to be realised, so that all non-local gates are implemented.</p></li>
<li><p>Some of the distributable packets the previous step demands us to realise may require entanglement between non-adjacent modules; we look for distributable packets sharing a common remote qubit with different modules and find Steiner trees that minimise the number of Bell states needed to simultaneously realise the corresponding multi-gate teleportations.</p></li>
</ol>
<p>Unfortunately, we encounter a new caveat. As explained in the following section, the presence of embedded gates can sometimes hinder the use of Steiner trees. This means that we need a fourth step in our workflow, which takes all of the knowledge about optimisation opportunities gathered so far and makes the final decision on how the non-local gates are implemented.</p>
<section id="solving-incongruencies-between-steiner-trees-and-embedding">
<h3>Solving incongruencies between Steiner trees and embedding<a class="headerlink" href="#solving-incongruencies-between-steiner-trees-and-embedding" title="Link to this heading">¶</a></h3>
<p>The root of the issue between Steiner trees and embedding is the same of that discussed in the section on “Embedding conflicts”: if we are not careful, the necessary correction gates introduced by embedding may be non-local, thus requiring extra Bell states and nullifying the savings we achieved with Steiner trees. An example of a simple circuit where this can happen is depicted in the figure below, where every qubit in circuit (a) is in a different module and the gates <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are in the same distributable packet, with the Hadamard gates and <span class="math notranslate nohighlight">\(CZ\)</span> gate being embedded.</p>
<p><img alt="Solving a simple incongruence" src="../../_images/alap.png" /></p>
<p>Figure (b) shows the connectivity between the modules and, according to the Steiner trees strategy previously discussed, we would like to “reuse” the entanglement between modules <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> to realise both the non-local gate between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(C\)</span> and that between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(D\)</span>. However, if we simply realise all connections at the beginning of the protocol, all of the four modules will be simultaneously connected, requiring some extra non-local correction gates depicted in red in figure (c). Alternatively, as shown in (d), we can simply delay the starting process between <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(D\)</span> until it is strictly necessary and, similarly, close the connection between <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span> before the embedded gate. In this way, we reach the best case scenario: we are reusing the entanglement between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> and we are implementing both <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> in the same distributable packet.</p>
<p>It is not always possible to reach this best case scenario, but we can come up with a strategy that will always output a valid distributed circuit and, when possible, land on ideal solutions such as that of figure (c) above. The idea that enables this is quite simple: always apply starting and ending processes as late as possible. This leads to the fourth step of our workflow:</p>
<ol class="arabic simple" start="4">
<li><p>Scan the original circuit from beginning to end and produce the distributed circuit as you go, following the choice of distributable packets from step 2. While doing so, create the entanglement between non-adjacent modules as suggested by the Steiner trees of step 3, but delay the application of each starting process until immediately before the first non-local gate that requires it – open connections as late as possible – and, similarly, apply each ending process immediately before any embeddable gate that would otherwise require non-local correction gates – close connections as late as possible.</p></li>
</ol>
<p>This process can be automated and the result of the complete workflow is a compilation pass that, given any user-defined circuit and a heterogenous network of modular quantum computers, outputs an equivalent distributed circuit. The number of Bell states consumed by such a distributed circuit is minimised using multi-gate teleportation, embedding and Steiner trees.</p>
</section>
</section>
<section id="conclusions">
<h2>Conclusions<a class="headerlink" href="#conclusions" title="Link to this heading">¶</a></h2>
<p>This blogpost has summarised the outcomes of a project with the University of Tokyo. The technical details can be found in [<a class="reference internal" href="#references"><span class="xref myst">1</span></a>] and [<a class="reference internal" href="#references"><span class="xref myst">2</span></a>], and the code implementing our approach is available as a <a class="reference external" href="https://github.com/CQCL/pytket-dqc">pytket extension</a>, hosted on an open sourced repository. What we have described in this blogpost corresponds to the <code class="docutils literal notranslate"><span class="pre">EmbedSteiner</span></code> workflow in our paper [<a class="reference internal" href="#references"><span class="xref myst">2</span></a>]. During the project we considered alternative workflows: on one hand, there is a further refinement of <code class="docutils literal notranslate"><span class="pre">EmbedSteiner</span></code>, where a fifth step looks for opportunities to implement non-local gates as <em>detached gates</em>, further reducing the number of Bell states consumed. We also provide an alternative workflow where, instead of focusing on embedding and then trying to use Steiner trees to improve the solution, we proceed the other way around, creating first an initial solution exploiting Steiner trees and then refining it with the help of embedding. Both approaches perform similarly, with the approach discussed in this blogpost doing slightly better for the circuits we benchmarked against in our paper.</p>
<p>In our work we have focused on the use of multi-gate teleportation exclusively, but we believe there is room for further gains if we combine multi-gate teleportation with standard qubit teleportation. Such an idea – in isolation from embedding and Steiner trees – has been explored in [<a class="reference internal" href="#references"><span class="xref myst">3</span></a>]. A limitation to our approaches is that our workflow does not consider a bound to the number of ancillary qubits used for communication; in appendix C of [<a class="reference internal" href="#references"><span class="xref myst">2</span></a>] we discuss that this can be enforced as a final refinement pass to any of our workflows. An alternative approach that does preemptively bound the number of ancillary qubits, but does not make use of embedding or Steiner trees, appears in [<a class="reference internal" href="#references"><span class="xref myst">3</span></a>]. Finally, we believe an exciting avenue of further work would be to extend our methods to <span class="math notranslate nohighlight">\(n\)</span>-qubit gates where <span class="math notranslate nohighlight">\(n &gt; 2\)</span> and to change the metric that we use to assess the efficiency of the distribution: instead of counting the number of Bell states consumed, estimate final error rate and overall computation time.</p>
<p>It is a standard strategy in engineering to turn to distributed modular architectures when scaling up single systems becomes more challenging than creating networks of them. The technology might not be ready just yet but, when distributed quantum computing arrives, we will need compilers to be ready to make the best use of it.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>J.Y. Wu, K. Matsui, T. Forrer, A. Soeda, P. Andres-Martinez, D. Mills, L. Henaut and M. Murao. “<a class="reference external" href="https://arxiv.org/abs/2212.12688">Entanglement-efficient bipartite-distributed quantum computing</a>”. Quantum 7 (2023): 1196.</p></li>
<li><p>P. Andres-Martinez, T. Forrer, D. Mills, J.Y. Wu, L. Henaut, K. Yamamoto, M. Murao and R. Duncan. “<a class="reference external" href="https://arxiv.org/abs/2305.14148">Distributing circuits over heterogeneous, modular quantum computing network architectures</a>”, in review.</p></li>
<li><p>R.G. Sundaram, H. Gupta and C.R. Ramakrishnan. “<a class="reference external" href="https://arxiv.org/abs/2206.06437">Distribution of quantum circuits over general quantum networks</a>”. 2022 IEEE International Conference on Quantum Computing and Engineering (QCE).</p></li>
<li><p>C. Piveteau and D. Sutter. “<a class="reference external" href="https://arxiv.org/abs/2205.00016">Circuit knitting with classical communication</a>”. IEEE Transactions on Information Theory (2023).</p></li>
<li><p>A. Cowtan, S. Dilkes, R. Duncan, A. Krajenbrink, W. Simmons and S. Sivarajah. “<a class="reference external" href="https://arxiv.org/abs/1902.08091">On the qubit routing problem</a>”. In 14th Conference on the Theory of Quantum Computation, Communication and Cryptography (TQC 2019).</p></li>
</ol>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
              Copyright &#169; 2024 Quantinuum Ltd. All rights reserved.
            </div>
            <div class="terms" style="display:flex; gap:0.5rem; align-items:center; margin: 0.25rem 0rem;">
              <a href="https://www.quantinuum.com/privacy-statement" target="_blank">Privacy Statement</a>
              <div role="separator">/</div>
              <a href="https://www.quantinuum.com/cookie-notice" target="_blank">Cookie Notice</a>
              <div role="separator">/</div>
              <a href="https://www.quantinuum.com/terms-conditions" target="_blank">Terms and Conditions</a>
            </div>
            Made with 
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Optimisation of Distributed Quantum Circuits</a><ul>
<li><a class="reference internal" href="#multi-gate-teleportation-and-embedding">Multi-gate teleportation and embedding</a><ul>
<li><a class="reference internal" href="#embedding-conflicts">Embedding conflicts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#heterogeneous-networks-of-modules">Heterogeneous networks of modules</a><ul>
<li><a class="reference internal" href="#solving-incongruencies-between-steiner-trees-and-embedding">Solving incongruencies between Steiner trees and embedding</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conclusions">Conclusions</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=187304be"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>