<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <id>https://docs.quantinuum.com/tket/blog/</id>
  <title>TKET Developer Blog</title>
  <updated>2025-02-16T17:06:51.456728+00:00</updated>
  <link href="https://docs.quantinuum.com/tket/blog/"/>
  <link href="https://docs.quantinuum.com/tket/blog/blog/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.io/" version="0.11.12">ABlog</generator>
  <entry>
    <id>https://docs.quantinuum.com/tket/blog/posts/dqc/</id>
    <title>Optimisation of Distributed Quantum Circuits</title>
    <updated>2024-01-18T00:00:00+00:00</updated>
    <author>
      <name>Pablo Andres-Martinez</name>
    </author>
    <content type="html">&lt;section id="optimisation-of-distributed-quantum-circuits"&gt;

&lt;p&gt;As quantum computers scale up, their basic components grow farther apart, increasing the challenge of driving accurate interactions between them. Distributed quantum computing proposes a strategy that focuses on separation of concerns: first, engineer a quantum computer that performs reliably on the limited number of qubit it can manage and, then, produce multiple copies of it and connect them together to create larger devices. This strategy establishes two abstract levels of qubit interactions: within a single quantum computing module and between different modules. An efficient quantum circuit would use as few of the latter inter-module qubit interactions as possible, since those will be the main bottleneck of the computation.&lt;/p&gt;
&lt;p&gt;From a user’s perspective, however, it is desirable to think of an architecture with &lt;span class="math notranslate nohighlight"&gt;\(k\)&lt;/span&gt; quantum modules of &lt;span class="math notranslate nohighlight"&gt;\(n\)&lt;/span&gt; qubits each as a large monolithic quantum computer of &lt;span class="math notranslate nohighlight"&gt;\(kn\)&lt;/span&gt; qubits. It is then the task of the quantum compiler to convert the user’s circuit into an equivalent one comprised of &lt;span class="math notranslate nohighlight"&gt;\(k\)&lt;/span&gt; different subcircuits – each of at most &lt;span class="math notranslate nohighlight"&gt;\(n\)&lt;/span&gt; qubits – orchestrated together in such a way that the quantum interactions between modules are minimised. This blogpost discusses approaches for the automatisation of such a task, which resulted from a research project in collaboration between Quantinuum and Mio Murao’s group from the University of Tokyo. For a more detailed discussion, please refer to the two papers we wrote on the subject [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;1&lt;/span&gt;&lt;/a&gt;] and [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;2&lt;/span&gt;&lt;/a&gt;]. The code implementing these approaches is available as a &lt;a class="reference external" href="https://github.com/CQCL/pytket-dqc"&gt;pytket extension&lt;/a&gt;. A Jupyter notebook showcasing its basic usage can be found &lt;a class="reference external" href="https://github.com/CQCL/pytket-dqc/blob/main/examples/basic_usage.ipynb"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In our framework, we assume that the bottleneck of the computation is at the interaction between modules, and that the cost of computation within a module is comparatively “free”. Consequently, we do not attempt to optimise the layout of the subcircuits. Of course, once the circuit is distributed efficiently, the next stage of optimisation would be to apply standard optimisation passes on each of the subcircuits to further optimise the internal execution in each module. Such passes are available in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pytket&lt;/span&gt;&lt;/code&gt; (see the &lt;a class="reference internal" href="#../user-guide/manual/manual_compiler.html"&gt;&lt;span class="xref myst"&gt;manual&lt;/span&gt;&lt;/a&gt;), including rebasing the circuit to the hardware’s native gateset, qubit routing [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;5&lt;/span&gt;&lt;/a&gt;] and overall circuit optimisation.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Schematic of how DQC fits in a compilation workflow" src="https://docs.quantinuum.com/tket/blog/_images/dqc_schematic.png" /&gt;&lt;/p&gt;
&lt;p&gt;We only allow quantum interactions between different modules in the form of shared Bell states. In particular, we make use of the following Bell state&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[\ket{\Phi^+} = \frac{1}{\sqrt{2}} \ket{00} + \frac{1}{\sqrt{2}} \ket{11}.\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Protocols such as quantum teleportation use these states as a resource to communicate quantum information between spatially separated parties. The metric we wish to minimise in our optimisation task is the number of Bell states required to execute the resulting distributed circuit. Our framework is agnostic in regards to how these Bell states are generated: they may be generated by an external device and shared between the quantum computing modules, it may be that each quantum module generates Bell states internally and shuttles one of the qubits to another module, or it may even be that Bell states are not actually realised physically, but instead simulated via sampling and classical postprocessing using circuit-knitting techniques [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;4&lt;/span&gt;&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;The problem of optimising a distributed quantum circuit can be split into two subproblems. The first one is &lt;em&gt;qubit allocation&lt;/em&gt;, where we decide which quantum computing module holds each qubit. Notice that, once qubits are allocated, some of the gates in the circuit may act on qubits located in different modules – we refer to these as &lt;em&gt;non-local gates&lt;/em&gt;. The second subproblem requires us to decide how each of these non-local gates will be implemented via the consumption of Bell states. A simple solution to the qubit allocation problem is to partition the circuit in such a way that the number of non-local gates is minimised; this can be achieved by applying standard graph partitioning algorithms to the connectivity graph of the circuit. We can obtain better qubit allocations if we take into account subtleties on how the non-local gates may be implemented, as discussed in our paper [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;2&lt;/span&gt;&lt;/a&gt;] and other works from the literature [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;3&lt;/span&gt;&lt;/a&gt;]. For the sake of simplicity, in this blogpost we assume qubit allocation is solved via the simple graph partitioning approach, so that we can move on to the more intriguing aspects of non-local gate implementation.&lt;/p&gt;
&lt;p&gt;The circuits that we will discuss here will be comprised of gates in the following universal gateset:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Notation of gates" src="https://docs.quantinuum.com/tket/blog/_images/gates.png" /&gt;&lt;/p&gt;
&lt;p&gt;We will refer to the different quantum computing modules using upper case letters &lt;span class="math notranslate nohighlight"&gt;\(A, B, ...\)&lt;/span&gt; and draw circuit diagrams with curly brackets to indicate that the selected qubits are all allocated to the specified module.&lt;/p&gt;
&lt;section id="multi-gate-teleportation-and-embedding"&gt;
&lt;h2&gt;Multi-gate teleportation and embedding&lt;/h2&gt;
&lt;p&gt;We expect most readers will be familiar with the standard quantum teleportation protocol, where an arbitrary qubit is sent from one party to another by consuming a previously shared Bell state, along with some extra classical communication. Similarly, we can devise a gate teleportation protocol, where a single Bell state is consumed to apply a gate to a remote qubit, without changing the party that originally held the qubit. Interestingly, we can push gate teleportation further and use a single Bell state to apply multiple gates acting on the same remote qubit. For this to be possible, each of the gates must share certain property formalised in [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;1&lt;/span&gt;&lt;/a&gt;]. In practical terms, multi-gate teleportation is possible whenever each of the gates being teleported are controlled gates, with the remote qubit acting as their control. The circuit diagram below shows how this can be achieved.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The multi-gate teleportation protocol" src="https://docs.quantinuum.com/tket/blog/_images/ejpp.png" /&gt;&lt;/p&gt;
&lt;p&gt;The wavy line within the gray box labelled “starting process” represents a Bell state shared between modules &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt;. All of the quantum gates in the second circuit are local, i.e. they act on qubits located in the same module. The rightmost diagram depicts our shorthand notation for the “starting process” and “ending process” as wavy arrows. We refer to the collection of non-local gates implemented by a single multi-gate teleportation protocol as a &lt;em&gt;distributable packet&lt;/em&gt;, or packet for short.&lt;/p&gt;
&lt;p&gt;On its simplest form, the multi-gate teleportation protocol requires that there are no additional gates between the starting process and ending process. A straightforward generalisation of this is to allow single-qubit &lt;span class="math notranslate nohighlight"&gt;\(Rz\)&lt;/span&gt; rotations acting on the remote qubit &lt;span class="math notranslate nohighlight"&gt;\(\hat{q}\)&lt;/span&gt;, since these commute with the controlled gates and can safely be applied before or after the multi-gate teleportation protocol. More interestingly, if there are &lt;span class="math notranslate nohighlight"&gt;\(CZ\)&lt;/span&gt; gates sandwiched between Hadamard gates, a multi-gate teleportation protocol can still be realised, at the cost of adding extra gates as shown in the diagram below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Basic example of embedding" src="https://docs.quantinuum.com/tket/blog/_images/embedding.png" /&gt;&lt;/p&gt;
&lt;p&gt;We refer to the additional &lt;span class="math notranslate nohighlight"&gt;\(CZ\)&lt;/span&gt; gate labelled &lt;span class="math notranslate nohighlight"&gt;\(x'\)&lt;/span&gt; above as a &lt;em&gt;correction gate&lt;/em&gt;. Notice that the correction gate &lt;span class="math notranslate nohighlight"&gt;\(x'\)&lt;/span&gt; acts on qubits that live in the same module &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt;, so the gate is local and it can readily be implemented in &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt;. We then say that the gate &lt;span class="math notranslate nohighlight"&gt;\(x\)&lt;/span&gt; has been &lt;em&gt;embedded&lt;/em&gt; within the multi-gate teleportation protocol. Notice that &lt;span class="math notranslate nohighlight"&gt;\(x\)&lt;/span&gt; itself is a non-local gate and a separate gate teleportation is required to implement it.&lt;/p&gt;
&lt;p&gt;We can now sketch the core of our non-local gate implementation approach. First, we scan the circuit and detect all distributable packets – that is, groups of contiguous non-local gates acting on the same qubit. We then check which of these packets are separated by a sequence of embeddable gates and, when possible, merge them together into a single distributable packet – again, implementable consuming just one Bell state. At the end of this process, each non-local gate in the circuit will be present in two packets: one for each of its two qubits. Realising either of the two packets via the multi-gate teleportation protocol would result in the non-local gate being implemented and, hence, the problem becomes a matter of selecting a subset of packets that, in conjunction, contain all of the non-local gates in the circuit. This can be represented and solved as a vertex covering problem on a graph where the vertices are packets and the edges are non-local gates. However, there is a caveat which can make our solution invalid, as discussed in the next section.&lt;/p&gt;
&lt;section id="embedding-conflicts"&gt;
&lt;h3&gt;Embedding conflicts&lt;/h3&gt;
&lt;p&gt;Assume we wish to realise two different distributable packets, each with a separate instance of the multi-gate teleportation protocol. All of the gates in one packet have their remote qubit in module &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt;, and the other packet has its remote qubit in module &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt;. Furthermore, assume both of these packets contain some common embedded gate &lt;span class="math notranslate nohighlight"&gt;\(x\)&lt;/span&gt;, as shown in figure (a) below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Example of an embedding conflict" src="https://docs.quantinuum.com/tket/blog/_images/conflict.png" /&gt;&lt;/p&gt;
&lt;p&gt;In figure (b) we show how distributing the packet with remote qubit in &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; would cause a correction gate &lt;span class="math notranslate nohighlight"&gt;\(y\)&lt;/span&gt; to appear, due to the embedding of &lt;span class="math notranslate nohighlight"&gt;\(x\)&lt;/span&gt;. Figure (c) shows the resulting equivalent circuit if we attempt to also distribute the other packet. The correction gate &lt;span class="math notranslate nohighlight"&gt;\(y'\)&lt;/span&gt; necessary to embed &lt;span class="math notranslate nohighlight"&gt;\(y\)&lt;/span&gt; turns out to be a non-local gate! This defeats the purpose of embedding, since the Bell state we saved from joining packets via embedding must now be spent on implementing a new non-local gate &lt;span class="math notranslate nohighlight"&gt;\(y'\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To avoid this situation, we can scan the packets selected by the vertex cover approach discussed above and detect when an embedding conflict would appear. For each conflict detected we must choose which of the two distributable packets will embed the offending gate. Since no two packets can embed the same gate, the other distributable packet must be split back into two separate packets, each to be realised by a different multi-gate teleportation protocol. The choice of which packets to split to solve all embedding conflicts is not immediately obvious but, fortunately, we can identify them automatically by solving another vertex covering problem on a slightly different graph, where now the edges represent conflicts between packets. The details can be found in [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;1&lt;/span&gt;&lt;/a&gt;]. Once this process is finished, we have reached a valid implementation of the non-local gates in the circuit, making use of the multi-gate teleportation protocol and embedding to reduce the number of Bell states that are required.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="heterogeneous-networks-of-modules"&gt;
&lt;h2&gt;Heterogeneous networks of modules&lt;/h2&gt;
&lt;p&gt;So far we have not given any thought to the topology of the network connecting the quantum computing modules. We can expect that the spatial layout of the modules may influence the connectivity between them, since creating Bell states between spatially adjacent modules might be easier.&lt;/p&gt;
&lt;p&gt;In this project, we chose not to make any assumptions on the inter-connectivity of the different quantum computing modules and, instead, ask the user to model their network topology as a graph. Given such a graph – where vertices are modules and edges are direct connections between them – a new optimisation opportunity arises. For instance, in figure (b) below, the path between module &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt; is of length two and, consequently, in order to implement the &lt;span class="math notranslate nohighlight"&gt;\(\beta\)&lt;/span&gt; gate we will need to consume two Bell states; fortunately, in doing so, the intermediate connection between &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt; can be used to implement the &lt;span class="math notranslate nohighlight"&gt;\(\alpha\)&lt;/span&gt; gate without any extra cost!&lt;/p&gt;
&lt;p&gt;&lt;img alt="Distribution using a Steiner tree" src="https://docs.quantinuum.com/tket/blog/_images/steiner.png" /&gt;&lt;/p&gt;
&lt;p&gt;Figure (c) above shows another case where we can save some Bell states by “reusing” common connections in the communication paths: module &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; needs to share some entanglement with both &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt; and with &lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt;; since they are both at distance two, we would naively need four Bell states, but we can save one by reusing the entanglement between &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(D\)&lt;/span&gt; for both paths. The task of finding efficient paths from one vertex of a graph (e.g. module &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt;) to a collection of other vertices (e.g. modules &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt;) using common edges as much as possible, so that the total number of edges (Bell states consumed) is minimised, is known in computer science as the Steiner tree problem. Being a well-studied problem, we can apply standard algorithms to find efficient solutions so that, so far, our workflow looks as follows:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;Decide qubit allocation, either via simple graph partitioning or some more subtle approach such as in [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;2&lt;/span&gt;&lt;/a&gt;] or [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;3&lt;/span&gt;&lt;/a&gt;].&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scan the circuit for distributable packets and embedding opportunities; using vertex covering indentify an efficient subset of these packets and embeddings to be realised, so that all non-local gates are implemented.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Some of the distributable packets the previous step demands us to realise may require entanglement between non-adjacent modules; we look for distributable packets sharing a common remote qubit with different modules and find Steiner trees that minimise the number of Bell states needed to simultaneously realise the corresponding multi-gate teleportations.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Unfortunately, we encounter a new caveat. As explained in the following section, the presence of embedded gates can sometimes hinder the use of Steiner trees. This means that we need a fourth step in our workflow, which takes all of the knowledge about optimisation opportunities gathered so far and makes the final decision on how the non-local gates are implemented.&lt;/p&gt;
&lt;section id="solving-incongruencies-between-steiner-trees-and-embedding"&gt;
&lt;h3&gt;Solving incongruencies between Steiner trees and embedding&lt;/h3&gt;
&lt;p&gt;The root of the issue between Steiner trees and embedding is the same of that discussed in the section on “Embedding conflicts”: if we are not careful, the necessary correction gates introduced by embedding may be non-local, thus requiring extra Bell states and nullifying the savings we achieved with Steiner trees. An example of a simple circuit where this can happen is depicted in the figure below, where every qubit in circuit (a) is in a different module and the gates &lt;span class="math notranslate nohighlight"&gt;\(\alpha\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(\beta\)&lt;/span&gt; are in the same distributable packet, with the Hadamard gates and &lt;span class="math notranslate nohighlight"&gt;\(CZ\)&lt;/span&gt; gate being embedded.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Solving a simple incongruence" src="https://docs.quantinuum.com/tket/blog/_images/alap.png" /&gt;&lt;/p&gt;
&lt;p&gt;Figure (b) shows the connectivity between the modules and, according to the Steiner trees strategy previously discussed, we would like to “reuse” the entanglement between modules &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt; to realise both the non-local gate between &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt; and that between &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(D\)&lt;/span&gt;. However, if we simply realise all connections at the beginning of the protocol, all of the four modules will be simultaneously connected, requiring some extra non-local correction gates depicted in red in figure (c). Alternatively, as shown in (d), we can simply delay the starting process between &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(D\)&lt;/span&gt; until it is strictly necessary and, similarly, close the connection between &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt; before the embedded gate. In this way, we reach the best case scenario: we are reusing the entanglement between &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(B\)&lt;/span&gt; and we are implementing both &lt;span class="math notranslate nohighlight"&gt;\(\alpha\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(\beta\)&lt;/span&gt; in the same distributable packet.&lt;/p&gt;
&lt;p&gt;It is not always possible to reach this best case scenario, but we can come up with a strategy that will always output a valid distributed circuit and, when possible, land on ideal solutions such as that of figure (c) above. The idea that enables this is quite simple: always apply starting and ending processes as late as possible. This leads to the fourth step of our workflow:&lt;/p&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;&lt;p&gt;Scan the original circuit from beginning to end and produce the distributed circuit as you go, following the choice of distributable packets from step 2. While doing so, create the entanglement between non-adjacent modules as suggested by the Steiner trees of step 3, but delay the application of each starting process until immediately before the first non-local gate that requires it – open connections as late as possible – and, similarly, apply each ending process immediately before any embeddable gate that would otherwise require non-local correction gates – close connections as late as possible.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This process can be automated and the result of the complete workflow is a compilation pass that, given any user-defined circuit and a heterogenous network of modular quantum computers, outputs an equivalent distributed circuit. The number of Bell states consumed by such a distributed circuit is minimised using multi-gate teleportation, embedding and Steiner trees.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="conclusions"&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;This blogpost has summarised the outcomes of a project with the University of Tokyo. The technical details can be found in [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;1&lt;/span&gt;&lt;/a&gt;] and [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;2&lt;/span&gt;&lt;/a&gt;], and the code implementing our approach is available as a &lt;a class="reference external" href="https://github.com/CQCL/pytket-dqc"&gt;pytket extension&lt;/a&gt;, hosted on an open sourced repository. What we have described in this blogpost corresponds to the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;EmbedSteiner&lt;/span&gt;&lt;/code&gt; workflow in our paper [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;2&lt;/span&gt;&lt;/a&gt;]. During the project we considered alternative workflows: on one hand, there is a further refinement of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;EmbedSteiner&lt;/span&gt;&lt;/code&gt;, where a fifth step looks for opportunities to implement non-local gates as &lt;em&gt;detached gates&lt;/em&gt;, further reducing the number of Bell states consumed. We also provide an alternative workflow where, instead of focusing on embedding and then trying to use Steiner trees to improve the solution, we proceed the other way around, creating first an initial solution exploiting Steiner trees and then refining it with the help of embedding. Both approaches perform similarly, with the approach discussed in this blogpost doing slightly better for the circuits we benchmarked against in our paper.&lt;/p&gt;
&lt;p&gt;In our work we have focused on the use of multi-gate teleportation exclusively, but we believe there is room for further gains if we combine multi-gate teleportation with standard qubit teleportation. Such an idea – in isolation from embedding and Steiner trees – has been explored in [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;3&lt;/span&gt;&lt;/a&gt;]. A limitation to our approaches is that our workflow does not consider a bound to the number of ancillary qubits used for communication; in appendix C of [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;2&lt;/span&gt;&lt;/a&gt;] we discuss that this can be enforced as a final refinement pass to any of our workflows. An alternative approach that does preemptively bound the number of ancillary qubits, but does not make use of embedding or Steiner trees, appears in [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;3&lt;/span&gt;&lt;/a&gt;]. Finally, we believe an exciting avenue of further work would be to extend our methods to &lt;span class="math notranslate nohighlight"&gt;\(n\)&lt;/span&gt;-qubit gates where &lt;span class="math notranslate nohighlight"&gt;\(n &amp;gt; 2\)&lt;/span&gt; and to change the metric that we use to assess the efficiency of the distribution: instead of counting the number of Bell states consumed, estimate final error rate and overall computation time.&lt;/p&gt;
&lt;p&gt;It is a standard strategy in engineering to turn to distributed modular architectures when scaling up single systems becomes more challenging than creating networks of them. The technology might not be ready just yet but, when distributed quantum computing arrives, we will need compilers to be ready to make the best use of it.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;J.Y. Wu, K. Matsui, T. Forrer, A. Soeda, P. Andres-Martinez, D. Mills, L. Henaut and M. Murao. “&lt;a class="reference external" href="https://arxiv.org/abs/2212.12688"&gt;Entanglement-efficient bipartite-distributed quantum computing&lt;/a&gt;”. Quantum 7 (2023): 1196.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;P. Andres-Martinez, T. Forrer, D. Mills, J.Y. Wu, L. Henaut, K. Yamamoto, M. Murao and R. Duncan. “&lt;a class="reference external" href="https://arxiv.org/abs/2305.14148"&gt;Distributing circuits over heterogeneous, modular quantum computing network architectures&lt;/a&gt;”, in review.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;R.G. Sundaram, H. Gupta and C.R. Ramakrishnan. “&lt;a class="reference external" href="https://arxiv.org/abs/2206.06437"&gt;Distribution of quantum circuits over general quantum networks&lt;/a&gt;”. 2022 IEEE International Conference on Quantum Computing and Engineering (QCE).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C. Piveteau and D. Sutter. “&lt;a class="reference external" href="https://arxiv.org/abs/2205.00016"&gt;Circuit knitting with classical communication&lt;/a&gt;”. IEEE Transactions on Information Theory (2023).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A. Cowtan, S. Dilkes, R. Duncan, A. Krajenbrink, W. Simmons and S. Sivarajah. “&lt;a class="reference external" href="https://arxiv.org/abs/1902.08091"&gt;On the qubit routing problem&lt;/a&gt;”. In 14th Conference on the Theory of Quantum Computation, Communication and Cryptography (TQC 2019).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://docs.quantinuum.com/tket/blog/posts/dqc/"/>
    <summary>As quantum computers scale up, their basic components grow farther apart, increasing the challenge of driving accurate interactions between them. Distributed quantum computing proposes a strategy that focuses on separation of concerns: first, engineer a quantum computer that performs reliably on the limited number of qubit it can manage and, then, produce multiple copies of it and connect them together to create larger devices. This strategy establishes two abstract levels of qubit interactions: within a single quantum computing module and between different modules. An efficient quantum circuit would use as few of the latter inter-module qubit interactions as possible, since those will be the main bottleneck of the computation.</summary>
    <published>2024-01-18T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://docs.quantinuum.com/tket/blog/posts/controlled_gates/</id>
    <title>Improved Controlled Gates in pytket</title>
    <updated>2023-10-24T00:00:00+00:00</updated>
    <author>
      <name>Callum Macpherson</name>
    </author>
    <content type="html">&lt;section id="improved-controlled-gates-in-pytket"&gt;

&lt;p&gt;Last week brought a new pytket 1.21.0 release! See the &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/changelog.html#october-2023"&gt;changelog&lt;/a&gt; for a rundown of all the new features and fixes. This blog will focus on improvements to controlled gates in pytket with the new &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/circuit.html#pytket.circuit.ConjugationBox"&gt;ConjugationBox&lt;/a&gt; feature enabling some key circuit primitives to be implemented far more efficiently. There are also some improvements to how controlled gates are displayed in the circuit renderer.&lt;/p&gt;
&lt;section id="examples-of-controlled-gates"&gt;
&lt;h2&gt;Examples of Controlled Gates&lt;/h2&gt;
&lt;p&gt;Controlled gates show up all the time in quantum computing. These gates modify a target qubit depending on the state of a control qubit (or a set of control qubits).&lt;/p&gt;
&lt;p&gt;Two commonly used controlled gates are the CX (or CNOT) gate and the CCZ gate.&lt;/p&gt;
&lt;div class="table-wrapper colwidths-auto docutils container"&gt;
&lt;table class="docutils align-default"&gt;
&lt;thead&gt;
&lt;tr class="row-odd"&gt;&lt;th class="head text-center"&gt;&lt;p&gt;CX&lt;/p&gt;&lt;/th&gt;
&lt;th class="head text-center"&gt;&lt;p&gt;CCZ&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="row-even"&gt;&lt;td class="text-center"&gt;&lt;p&gt;&lt;img alt="" src="https://docs.quantinuum.com/tket/blog/_images/CX.png" /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="text-center"&gt;&lt;p&gt;&lt;img alt="" src="https://docs.quantinuum.com/tket/blog/_images/CCZ.png" /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;As you probably know, the action of the CX gate is to apply a X operation to flip the state of a target qubit if its control qubit is in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state. If the control qubit is not in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state then this gate acts as the identity gate.&lt;/p&gt;
&lt;p&gt;We can understand the action of the CX gate on a two qubit state by looking at its truth table. The CX gate has the following action on the two qubit computational basis states.&lt;/p&gt;
&lt;div class="table-wrapper colwidths-auto docutils container"&gt;
&lt;table class="docutils align-default"&gt;
&lt;thead&gt;
&lt;tr class="row-odd"&gt;&lt;th class="head"&gt;&lt;p&gt;Input State&lt;/p&gt;&lt;/th&gt;
&lt;th class="head"&gt;&lt;p&gt;Output State&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;00&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;00&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;01&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;01&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;10&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;11&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;11&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;10&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;The action of the CCZ gate shown above is to add a phase of &lt;span class="math notranslate nohighlight"&gt;\(-1\)&lt;/span&gt; if both control qubits are in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state. So if the combined state of both controls is &lt;span class="math notranslate nohighlight"&gt;\(|11\rangle\)&lt;/span&gt;, then a Pauli Z operation is applied to the target qubit.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="some-terminology"&gt;
&lt;h2&gt;Some Terminology&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Control state:&lt;/strong&gt; The state that the control qubits must be in for the operation to be applied to the target. Typically we assume that the control state is “all &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;” unless specified otherwise. However this need not be the case. In general the control state can be any string of &lt;span class="math notranslate nohighlight"&gt;\(|0\rangle\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Base gate:&lt;/strong&gt; The operation that is applied to the target qubit(s) when the control qubits are in the control state. So for the CCZ gate above the control state is &lt;span class="math notranslate nohighlight"&gt;\(|11\rangle\)&lt;/span&gt; and the base gate is the Pauli &lt;span class="math notranslate nohighlight"&gt;\(Z\)&lt;/span&gt; operation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conjugation pattern:&lt;/strong&gt; We say that a unitary operation &lt;span class="math notranslate nohighlight"&gt;\(U_c\)&lt;/span&gt; fits the conjugation pattern if it can be expressed as follows&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
U_{c} = V \, A \, V^\dagger \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This compute (&lt;span class="math notranslate nohighlight"&gt;\(V\)&lt;/span&gt;), action (&lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt;), uncompute (&lt;span class="math notranslate nohighlight"&gt;\(V^\dagger\)&lt;/span&gt;) pattern occurs frequently in quantum computing. This pattern is captured by the new &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; construct in pytket.&lt;/p&gt;
&lt;p&gt;In pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;1.21.0&lt;/span&gt;&lt;/code&gt; we can find much smarter decompositions for controlled gates where the base gate fits the conjugation pattern &lt;span class="math notranslate nohighlight"&gt;\(V \, A \, V^\dagger\)&lt;/span&gt;. The trick here is that to construct a controlled &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; you only have to control on the central &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; operation rather than every single gate in the circuit.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="an-example-using-pauli-gadgets"&gt;
&lt;h2&gt;An Example Using Pauli Gadgets&lt;/h2&gt;
&lt;p&gt;Shown below is an example of a Pauli gadget circuit. This is a great example of a common circuit primitive that fits the conjugation pattern &lt;span class="math notranslate nohighlight"&gt;\(V \, A \, V^\dagger\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="align-center" src="https://docs.quantinuum.com/tket/blog/_images/Pauli_gadget.png" /&gt;&lt;/p&gt;
&lt;p&gt;This circuit implements a unitary of the form &lt;span class="math notranslate nohighlight"&gt;\( U = e^{-i \frac{\pi}{2} \theta P}\)&lt;/span&gt; where &lt;span class="math notranslate nohighlight"&gt;\(\theta = 0.7\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; is a tensor product of Pauli operators.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
P = Z \otimes Z \otimes Y \otimes X 
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This type of operation shows up very naturally in quantum chemistry when trotterising Hamiltonians. Readers familiar with the quantum phase estimation algorithm (QPE) may know that QPE requires many controlled unitary operations to implement. Often the unitary will be a time evolved Hamiltonian represented by a Pauli gadget. So being able to implement these controlled unitaries efficiently could reduce the complexity of the circuit needed for QPE.&lt;/p&gt;
&lt;p&gt;In addition to having the form of a conjugation pattern, Pauli gadget circuits have some cool algebraic properties that can be exploited for circuit optimisation [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;1&lt;/span&gt;&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;Now if we squint at the circuit diagram above, we see that it’s almost symmetric around the central Rz rotation. In fact, the left hand side of the Rz gate is exactly the dagger of the right hand side. If we identify the central Rz gate as the action &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; then it is clear that the subcircuits to the left and right hand side of &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; can be identified with &lt;span class="math notranslate nohighlight"&gt;\( V\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(V^\dagger\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Since all Pauli gadget circuits are in the form of a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt;, it is sufficient to simply control on the central Rz operation like so.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="align-center" src="https://docs.quantinuum.com/tket/blog/_images/controlled_pauliZZYX.png" /&gt;&lt;/p&gt;
&lt;p&gt;Let’s now construct a circuit for this Pauli gadget using pytket’s &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; construction. More information on &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; can be found in the &lt;a class="reference internal" href="#../user-guide/manual/manual_circuit.html#pauli-exponential-boxes"&gt;&lt;span class="xref myst"&gt;user manual&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.pauli&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;PauliExpBox&lt;/span&gt;

&lt;span class="n"&gt;zzyx_box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PauliExpBox&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now we can construct a controlled &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;. A &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; is now handled internally as a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; so the controlled operation can be done much more efficiently.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="c1"&gt;# A controlled PauliExpBox with a single control (n=1)&lt;/span&gt;
&lt;span class="n"&gt;controlled_zzyx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zzyx_box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now that we have our constructed our controlled unitary, we can do a comparison between pytket versions to highlight the benefit on the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s run the code below with pytket 1.20.1 and pytket 1.21 and compare the number of gates required to implement this controlled Pauli gadget. We will decompose the boxes and compile the circuit down to one and two qubit gates with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SynthesiseTK&lt;/span&gt;&lt;/code&gt; pass to ensure a fair comparison.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.passes&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;DecomposeBoxes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SynthesiseTK&lt;/span&gt;

&lt;span class="n"&gt;test_circ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_gate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;controlled_zzyx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="n"&gt;DecomposeBoxes&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;SynthesiseTK&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Total gate count:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n_gates&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2 qubit gates:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n_2qb_gates&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pytket 1.20.1&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="n"&gt;gate&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;103&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;qubit&lt;/span&gt; &lt;span class="n"&gt;gates&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;44&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pytket 1.21.0&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="n"&gt;gate&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;qubit&lt;/span&gt; &lt;span class="n"&gt;gates&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now that’s a big difference! We see pytket 1.21.0 is able to use the underlying &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjuagtionBox&lt;/span&gt;&lt;/code&gt; structure of the Pauli gadget to find a far more efficient implementation.&lt;/p&gt;
&lt;p&gt;The improvement in the number of two qubit entangling gates is particularly nice when we think about running circuits on real quantum hardware. Entangling gates are in general much more noisy than single qubit gates so getting rid of them where possible can be great for boosting the fidelity of our computation.&lt;/p&gt;
&lt;p&gt;The reason for the reduction is that pytket 1.21.0 can simply control on the single Rz in the Pauli gadget. Previously if we wanted to construct a controlled Pauli gadget, pytket would naively construct a controlled version of every single gate in the base Pauli gadget circuit. In version 1.20.1, pytket naively converts all of the CX gates to CCX gates and then has to compile those down to one and two qubit gates with a significant overhead.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;We have shown how we can compile controlled Pauli gadget circuits by making use of the conjugation pattern. This is now logic internal to pytket.&lt;/p&gt;
&lt;p&gt;You can also define your own &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/circuit.html#pytket.circuit.ConjugationBox"&gt;ConjugationBox&lt;/a&gt; by providing a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;compute&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;action&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;uncompute&lt;/span&gt;&lt;/code&gt; operation. Can you think of other cases where this construct would be useful?&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="some-mathematical-details"&gt;
&lt;h2&gt;Some Mathematical Details&lt;/h2&gt;
&lt;p&gt;So why does this work?&lt;/p&gt;
&lt;p&gt;Here we will show that if we have a controlled gate whose base gates fits the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; pattern then it is only necessary to control on the central &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; operation.&lt;/p&gt;
&lt;p&gt;Recall the the form of the conjugation pattern&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
U_c = V \, A \, V^\dagger \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To avoid ambiguity in what follows we will denote a controlled-&lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; operation as &lt;span class="math notranslate nohighlight"&gt;\(C[P]\)&lt;/span&gt; where &lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; is some unitary operator.&lt;/p&gt;
&lt;p&gt;Now we want to show that&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
C[U_c] = C[V \, A \, V^\dagger] = (I \otimes V) C[A] (I \otimes V^\dagger)\, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;A controlled-&lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; operation can be expanded out as follows&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
C[P]= |0\rangle\langle 0| \otimes I + |1\rangle\langle1| \otimes P \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To prove our result let’s take the right hand side of our target equation and expand the &lt;span class="math notranslate nohighlight"&gt;\(C[A]\)&lt;/span&gt; term.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[\begin{split}
\begin{align}
(I \otimes V) C[A] (I \otimes V^\dagger) &amp;amp;= (I \otimes V ) \,( |0\rangle\langle 0| \otimes I + |1\rangle\langle1| \otimes A )\, (I \otimes V^\dagger) \\
&amp;amp;= |0\rangle\langle 0| \otimes \cancelto{I}{V \, I \, V^\dagger} + |1\rangle\langle1| \otimes V \, A \, V^\dagger \\
\implies (I \otimes V) C[A] (I \otimes V^\dagger) &amp;amp;= |0\rangle\langle 0| \otimes I + |1\rangle\langle1| \otimes U_c = C[U_c]
\end{align}
\end{split}\]&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;A. Cowtan, S. Dilkes, R. Duncan, W. Simmons, and
S. Sivarajah, “Phase gadget synthesis for shallow circuits,” in 16th International Conference on Quantum
Physics and Logic 2019. Open Publishing Association,
2019, pp. 213–228&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://docs.quantinuum.com/tket/blog/posts/controlled_gates/"/>
    <summary>Last week brought a new pytket 1.21.0 release! See the changelog for a rundown of all the new features and fixes. This blog will focus on improvements to controlled gates in pytket with the new ConjugationBox feature enabling some key circuit primitives to be implemented far more efficiently. There are also some improvements to how controlled gates are displayed in the circuit renderer.</summary>
    <published>2023-10-24T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://docs.quantinuum.com/tket/blog/posts/september_release_pytket/</id>
    <title>September Release Notes (pytket)</title>
    <updated>2023-09-08T00:00:00+00:00</updated>
    <author>
      <name>Callum Macpherson</name>
    </author>
    <content type="html">&lt;section id="september-release-notes-pytket"&gt;

&lt;p&gt;The September release brings typing improvements, custom control states in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;, equality checking for pytket boxes and more.&lt;/p&gt;
&lt;section id="pytket-1-19-0"&gt;
&lt;h2&gt;pytket 1.19.0&lt;/h2&gt;
&lt;section id="new-features-changelog"&gt;
&lt;h3&gt;New Features (&lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/changelog.html"&gt;Changelog&lt;/a&gt;)&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#typing-improvements-for-compiled-pytket-modules"&gt;&lt;span class="xref myst"&gt;Typing for compiled modules&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#custom-control-states-in-qcontrolbox"&gt;&lt;span class="xref myst"&gt;Custom control states in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#new-conjugationbox-construction"&gt;&lt;span class="xref myst"&gt;New &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; construction&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#equality-checking-for-all-box-types"&gt;&lt;span class="xref myst"&gt;Equality checking implemented for all boxes&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#every-pytket-op-now-has-an-is-clifford-method"&gt;&lt;span class="xref myst"&gt;Every pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; now has an &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;is_clifford&lt;/span&gt;&lt;/code&gt; method&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#qubitpaulitensor-class"&gt;&lt;span class="xref myst"&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; class is now available in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pytket.pauli&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="fixes-1-19-0"&gt;
&lt;h3&gt;Fixes (1.19.0)&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;It is now possible to create an empty &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;BackendResult&lt;/span&gt;&lt;/code&gt; object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Performance fix for symbolic angle squashing.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="update-fixes-1-19-1"&gt;
&lt;h3&gt;Update - Fixes (1.19.1)&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Fix for a regression in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RebaseCustom&lt;/span&gt;&lt;/code&gt;. The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RebaseCustom&lt;/span&gt;&lt;/code&gt; pass would fail to convert circuits containing TK2 gates due to a change released in a previous version. This is now fixed in 1.19.1.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fix to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Circuit.symbol_substitution&lt;/span&gt;&lt;/code&gt; for circuits containing box types that don’t support symbol substitution. Boxes which don’t support symbol substitution include the &lt;a class="reference external" href="https://docs.quantinuum.com/tket/user-guide/manual/manual_circuit.html#boxes-for-unitary-synthesis"&gt;unitary synthesis boxes&lt;/a&gt; and &lt;a class="reference external" href="https://docs.quantinuum.com/tket/user-guide/manual/manual_assertion.html"&gt;assertion boxes&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="typing-improvements-for-compiled-pytket-modules"&gt;
&lt;h3&gt;Typing improvements for compiled pytket modules&lt;/h3&gt;
&lt;p&gt;In previous versions of pytket, type information was not available for any of the compiled modules, which represent a large part of the library.&lt;/p&gt;
&lt;p&gt;For this reason, when using type checkers such as mypy or pyright, it was necessary to use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;#&lt;/span&gt; &lt;span class="pre"&gt;type:&lt;/span&gt; &lt;span class="pre"&gt;ignore&lt;/span&gt;&lt;/code&gt; statements like the following.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt; &lt;span class="c1"&gt;# type: ignore&lt;/span&gt;

&lt;span class="n"&gt;my_circbox&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This also meant that certain type hints and auto complete feature were not available to developers when using compiled modules such as &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pytket.circuit&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pytket.passes&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;pytket now includes type information for all compiled modules via automatically generated type stub files. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;#&lt;/span&gt; &lt;span class="pre"&gt;type:&lt;/span&gt; &lt;span class="pre"&gt;ignore&lt;/span&gt;&lt;/code&gt; statements are no longer needed. This means that developers can use type checkers more freely and take advantage of type hints and autocomplete when working with pytket.&lt;/p&gt;
&lt;p&gt;Note that using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;#&lt;/span&gt; &lt;span class="pre"&gt;type:&lt;/span&gt; &lt;span class="pre"&gt;ignore&lt;/span&gt;&lt;/code&gt; does not suppress type information if it is available. This means that type checking runs that were previously passing may now fail if the usage of objects from compiled modules is deemed improper by the type checker.&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;In order to use some of the &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/extensions.html"&gt;pytket extension modules&lt;/a&gt; with pytket 1.19.0 or newer, you will need to use a version of the extension package that was released in September 2023 or later. This is due to the typing changes in the pytket 1.19.0 release.&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="custom-control-states-in-qcontrolbox"&gt;
&lt;h3&gt;Custom control states in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; provides an interface for users to define controlled unitary operations.&lt;/p&gt;
&lt;p&gt;Given a pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; we can define a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; as follows&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="n"&gt;s_gate_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;cccs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s_gate_op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# define a CCCS gate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Here we have defined &lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate controlled on 3 qubits. This means that an S will be applied when all 3 control qubits are in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state.&lt;/p&gt;
&lt;p&gt;However prior to the 1.19 release a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; could only be defined using the “all &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;” control state.&lt;/p&gt;
&lt;p&gt;This has now changed and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; now accepts a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;control_state&lt;/span&gt;&lt;/code&gt; argument. If no &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;control_state&lt;/span&gt;&lt;/code&gt; argument is provided then the default “all &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;” state is used. Lets define a controlled-&lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate with a control state of &lt;span class="math notranslate nohighlight"&gt;\(|010\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="n"&gt;s_gate_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;custom_cccs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s_gate_op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;control_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
&lt;span class="c1"&gt;# Equivalent to the above (using an integer control_state)&lt;/span&gt;
&lt;span class="c1"&gt;# custom_cccs = QControlBox(op, 3, control_state=2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now the &lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate will be applied to the target when the three control qubits are in the &lt;span class="math notranslate nohighlight"&gt;\(|010\rangle\)&lt;/span&gt; state.&lt;/p&gt;
&lt;p&gt;These sorts of gates appear frequently in quantum algorithms. Here is a simple example of an LCU (Linear combination of unitaries) circuit.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://docs.quantinuum.com/tket/blog/_images/lcu_diagram.png" /&gt;&lt;/p&gt;
&lt;p&gt;This circuit can be used to calculate the expectation value of the sum of &lt;span class="math notranslate nohighlight"&gt;\(U_a\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(U_b\)&lt;/span&gt;. Here the empty circle in the second control gates denotes a “0-controlled” gate.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
 \langle U_a + U_b \rangle =  \langle  \psi| U_{a} + U_{b} | \psi \rangle
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Suppose we create a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CircBox&lt;/span&gt;&lt;/code&gt; for the &lt;span class="math notranslate nohighlight"&gt;\(U_a\)&lt;/span&gt; operation. We can then construct a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; for the 0-controlled &lt;span class="math notranslate nohighlight"&gt;\(U_a\)&lt;/span&gt; as follows&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="n"&gt;ub_box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 

&lt;span class="n"&gt;zero_controlled_ub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ub_box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;control_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="every-pytket-op-now-has-an-is-clifford-method"&gt;
&lt;h3&gt;Every pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; now has an &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;is_clifford&lt;/span&gt;&lt;/code&gt; method&lt;/h3&gt;
&lt;p&gt;Clifford circuits are an important class of quantum circuits known to exhibit efficient classical simulation.&lt;/p&gt;
&lt;p&gt;A Clifford gate is an element of the Clifford group which can be generated by the &lt;span class="math notranslate nohighlight"&gt;\(\{H, S, CX\}\)&lt;/span&gt; operations. Such operations map Pauli operations &lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; to other Pauli operations &lt;span class="math notranslate nohighlight"&gt;\(P'\)&lt;/span&gt;  when conjugated as follows&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
P' = C \, P \, C^\dagger \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;For instance a Pauli &lt;span class="math notranslate nohighlight"&gt;\(X\)&lt;/span&gt; can be transformed to a Pauli &lt;span class="math notranslate nohighlight"&gt;\(Z\)&lt;/span&gt; by conjugating with a Hadamard Gate.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
X = H \, Z \, H^\dagger = H \, Z \, H \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Given a pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; we could check whether it was a Clifford type operation with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op.is_clifford_type&lt;/span&gt;&lt;/code&gt; method.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OpType&lt;/span&gt;

&lt;span class="n"&gt;s_gate_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s_gate_op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_clifford_type&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This returns &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;True&lt;/span&gt;&lt;/code&gt;, the &lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate is a well known Clifford gate.&lt;/p&gt;
&lt;p&gt;However &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op.is_clifford_type&lt;/span&gt;&lt;/code&gt; is limited as it only checks whether the underlying &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;OpType&lt;/span&gt;&lt;/code&gt; is Clifford. This check would not be able to handle the case of parameterised gates that have Clifford angles.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;rz_clifford_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Rz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;rz_clifford_op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_clifford_type&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Here we have defined the Rz op with the &lt;span class="math notranslate nohighlight"&gt;\(1\)&lt;/span&gt; rotation parameter (equivalent to 1 half turn).
The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;is_clifford_type&lt;/span&gt;&lt;/code&gt; method will return &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/code&gt; here as the Rz gate is not in general a Clifford gate.&lt;/p&gt;
&lt;p&gt;However in pytket 1.19 we can now use the more general &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op.is_clifford()&lt;/span&gt;&lt;/code&gt; method.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;rz_clifford_op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_clifford&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This method will now correctly identify the Rz gate as a Clifford by checking whether the parameter is a Clifford angle.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="qubitpaulitensor-class"&gt;
&lt;h3&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; class&lt;/h3&gt;
&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; class is now exposed to pytket. A &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; is defined using a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliString&lt;/span&gt;&lt;/code&gt; paired with a complex coefficient.&lt;/p&gt;
&lt;p&gt;This allows phase to be tracked when using the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;UnitaryTableau&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="equality-checking-for-all-box-types"&gt;
&lt;h3&gt;Equality checking for all box types&lt;/h3&gt;
&lt;p&gt;A pytket box represents a higher level subroutine that can be added to a quantum circuit. For more on the different types of box available in pytket, read the &lt;a class="reference internal" href="#../user-guide/manual/manual_circuit.html#boxes"&gt;&lt;span class="xref myst"&gt;user manual section&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After the pytket 1.19 release, every box type now allows for equivalence checking.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;

&lt;span class="n"&gt;ghz_circ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;GHZ&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Construct two equivalent CircBox objects&lt;/span&gt;
&lt;span class="n"&gt;box1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ghz_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;box2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ghz_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;box1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;box2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This equality check will now return &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;True&lt;/span&gt;&lt;/code&gt; in pytket 1.19. In older versions of pytket, the equality check would return &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Being able to test for equivalence is useful for testing purposes. We can validate the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CircBox&lt;/span&gt;&lt;/code&gt; without decomposing it or having to defer to the underlying circuit with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CircBox.get_circuit()&lt;/span&gt;&lt;/code&gt; method.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="new-conjugationbox-construction"&gt;
&lt;h3&gt;New &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; construction&lt;/h3&gt;
&lt;p&gt;Another enhancement related to controlled gates is the new &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; feature. This allows us to find efficient decompositions for controlled gates when our base gate &lt;span class="math notranslate nohighlight"&gt;\(U_{\text{conj}}\)&lt;/span&gt; is of the form&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
U_\text{conj} = C \, A \, C^\dagger
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Where &lt;span class="math notranslate nohighlight"&gt;\(U_{\text{conj}},\, A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt; are unitary operations.&lt;/p&gt;
&lt;p&gt;This compute (&lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt;), action (&lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt;), uncompute (&lt;span class="math notranslate nohighlight"&gt;\(C^\dagger\)&lt;/span&gt;) pattern occurs frequently in various applications of quantum computing. It can be shown that to construct a controlled &lt;span class="math notranslate nohighlight"&gt;\(U_{\text{conj}}\)&lt;/span&gt; operation it is only necessary to control on the central &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; operation.&lt;/p&gt;
&lt;p&gt;Enhancements to this feature will be added in a subsequent release to handle &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; objects inside &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;, enabling more efficient compilation.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://docs.quantinuum.com/tket/blog/posts/september_release_pytket/"/>
    <summary>The September release brings typing improvements, custom control states in QControlBox, equality checking for pytket boxes and more.</summary>
    <published>2023-09-08T00:00:00+00:00</published>
  </entry>
</feed>
