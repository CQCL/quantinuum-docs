<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <id>https://docs.quantinuum.com/tket/blog/</id>
  <title>TKET Developer Blog - Posts by Callum Macpherson</title>
  <updated>2025-03-03T11:26:08.610780+00:00</updated>
  <link href="https://docs.quantinuum.com/tket/blog/"/>
  <link href="https://docs.quantinuum.com/tket/blog/blog/author/callum-macpherson/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.io/" version="0.11.12">ABlog</generator>
  <entry>
    <id>https://docs.quantinuum.com/tket/blog/posts/controlled_gates/</id>
    <title>Improved Controlled Gates in pytket</title>
    <updated>2023-10-24T00:00:00+00:00</updated>
    <author>
      <name>Callum Macpherson</name>
    </author>
    <content type="html">&lt;section id="improved-controlled-gates-in-pytket"&gt;

&lt;p&gt;Last week brought a new pytket 1.21.0 release! See the &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/changelog.html#october-2023"&gt;changelog&lt;/a&gt; for a rundown of all the new features and fixes. This blog will focus on improvements to controlled gates in pytket with the new &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/circuit.html#pytket.circuit.ConjugationBox"&gt;ConjugationBox&lt;/a&gt; feature enabling some key circuit primitives to be implemented far more efficiently. There are also some improvements to how controlled gates are displayed in the circuit renderer.&lt;/p&gt;
&lt;section id="examples-of-controlled-gates"&gt;
&lt;h2&gt;Examples of Controlled Gates&lt;/h2&gt;
&lt;p&gt;Controlled gates show up all the time in quantum computing. These gates modify a target qubit depending on the state of a control qubit (or a set of control qubits).&lt;/p&gt;
&lt;p&gt;Two commonly used controlled gates are the CX (or CNOT) gate and the CCZ gate.&lt;/p&gt;
&lt;div class="table-wrapper colwidths-auto docutils container"&gt;
&lt;table class="docutils align-default"&gt;
&lt;thead&gt;
&lt;tr class="row-odd"&gt;&lt;th class="head text-center"&gt;&lt;p&gt;CX&lt;/p&gt;&lt;/th&gt;
&lt;th class="head text-center"&gt;&lt;p&gt;CCZ&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="row-even"&gt;&lt;td class="text-center"&gt;&lt;p&gt;&lt;img alt="" src="https://docs.quantinuum.com/tket/blog/_images/CX.png" /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="text-center"&gt;&lt;p&gt;&lt;img alt="" src="https://docs.quantinuum.com/tket/blog/_images/CCZ.png" /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;As you probably know, the action of the CX gate is to apply a X operation to flip the state of a target qubit if its control qubit is in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state. If the control qubit is not in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state then this gate acts as the identity gate.&lt;/p&gt;
&lt;p&gt;We can understand the action of the CX gate on a two qubit state by looking at its truth table. The CX gate has the following action on the two qubit computational basis states.&lt;/p&gt;
&lt;div class="table-wrapper colwidths-auto docutils container"&gt;
&lt;table class="docutils align-default"&gt;
&lt;thead&gt;
&lt;tr class="row-odd"&gt;&lt;th class="head"&gt;&lt;p&gt;Input State&lt;/p&gt;&lt;/th&gt;
&lt;th class="head"&gt;&lt;p&gt;Output State&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;00&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;00&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;01&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;01&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;10&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;11&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;11&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;10&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;The action of the CCZ gate shown above is to add a phase of &lt;span class="math notranslate nohighlight"&gt;\(-1\)&lt;/span&gt; if both control qubits are in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state. So if the combined state of both controls is &lt;span class="math notranslate nohighlight"&gt;\(|11\rangle\)&lt;/span&gt;, then a Pauli Z operation is applied to the target qubit.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="some-terminology"&gt;
&lt;h2&gt;Some Terminology&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Control state:&lt;/strong&gt; The state that the control qubits must be in for the operation to be applied to the target. Typically we assume that the control state is “all &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;” unless specified otherwise. However this need not be the case. In general the control state can be any string of &lt;span class="math notranslate nohighlight"&gt;\(|0\rangle\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Base gate:&lt;/strong&gt; The operation that is applied to the target qubit(s) when the control qubits are in the control state. So for the CCZ gate above the control state is &lt;span class="math notranslate nohighlight"&gt;\(|11\rangle\)&lt;/span&gt; and the base gate is the Pauli &lt;span class="math notranslate nohighlight"&gt;\(Z\)&lt;/span&gt; operation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conjugation pattern:&lt;/strong&gt; We say that a unitary operation &lt;span class="math notranslate nohighlight"&gt;\(U_c\)&lt;/span&gt; fits the conjugation pattern if it can be expressed as follows&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
U_{c} = V \, A \, V^\dagger \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This compute (&lt;span class="math notranslate nohighlight"&gt;\(V\)&lt;/span&gt;), action (&lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt;), uncompute (&lt;span class="math notranslate nohighlight"&gt;\(V^\dagger\)&lt;/span&gt;) pattern occurs frequently in quantum computing. This pattern is captured by the new &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; construct in pytket.&lt;/p&gt;
&lt;p&gt;In pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;1.21.0&lt;/span&gt;&lt;/code&gt; we can find much smarter decompositions for controlled gates where the base gate fits the conjugation pattern &lt;span class="math notranslate nohighlight"&gt;\(V \, A \, V^\dagger\)&lt;/span&gt;. The trick here is that to construct a controlled &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; you only have to control on the central &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; operation rather than every single gate in the circuit.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="an-example-using-pauli-gadgets"&gt;
&lt;h2&gt;An Example Using Pauli Gadgets&lt;/h2&gt;
&lt;p&gt;Shown below is an example of a Pauli gadget circuit. This is a great example of a common circuit primitive that fits the conjugation pattern &lt;span class="math notranslate nohighlight"&gt;\(V \, A \, V^\dagger\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="align-center" src="https://docs.quantinuum.com/tket/blog/_images/Pauli_gadget.png" /&gt;&lt;/p&gt;
&lt;p&gt;This circuit implements a unitary of the form &lt;span class="math notranslate nohighlight"&gt;\( U = e^{-i \frac{\pi}{2} \theta P}\)&lt;/span&gt; where &lt;span class="math notranslate nohighlight"&gt;\(\theta = 0.7\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; is a tensor product of Pauli operators.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
P = Z \otimes Z \otimes Y \otimes X 
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This type of operation shows up very naturally in quantum chemistry when trotterising Hamiltonians. Readers familiar with the quantum phase estimation algorithm (QPE) may know that QPE requires many controlled unitary operations to implement. Often the unitary will be a time evolved Hamiltonian represented by a Pauli gadget. So being able to implement these controlled unitaries efficiently could reduce the complexity of the circuit needed for QPE.&lt;/p&gt;
&lt;p&gt;In addition to having the form of a conjugation pattern, Pauli gadget circuits have some cool algebraic properties that can be exploited for circuit optimisation [&lt;a class="reference internal" href="#references"&gt;&lt;span class="xref myst"&gt;1&lt;/span&gt;&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;Now if we squint at the circuit diagram above, we see that it’s almost symmetric around the central Rz rotation. In fact, the left hand side of the Rz gate is exactly the dagger of the right hand side. If we identify the central Rz gate as the action &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; then it is clear that the subcircuits to the left and right hand side of &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; can be identified with &lt;span class="math notranslate nohighlight"&gt;\( V\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(V^\dagger\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Since all Pauli gadget circuits are in the form of a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt;, it is sufficient to simply control on the central Rz operation like so.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" class="align-center" src="https://docs.quantinuum.com/tket/blog/_images/controlled_pauliZZYX.png" /&gt;&lt;/p&gt;
&lt;p&gt;Let’s now construct a circuit for this Pauli gadget using pytket’s &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; construction. More information on &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; can be found in the &lt;a class="reference internal" href="#../user-guide/manual/manual_circuit.html#pauli-exponential-boxes"&gt;&lt;span class="xref myst"&gt;user manual&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.pauli&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;PauliExpBox&lt;/span&gt;

&lt;span class="n"&gt;zzyx_box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PauliExpBox&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pauli&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now we can construct a controlled &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;. A &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PauliExpBox&lt;/span&gt;&lt;/code&gt; is now handled internally as a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; so the controlled operation can be done much more efficiently.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="c1"&gt;# A controlled PauliExpBox with a single control (n=1)&lt;/span&gt;
&lt;span class="n"&gt;controlled_zzyx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zzyx_box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now that we have our constructed our controlled unitary, we can do a comparison between pytket versions to highlight the benefit on the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s run the code below with pytket 1.20.1 and pytket 1.21 and compare the number of gates required to implement this controlled Pauli gadget. We will decompose the boxes and compile the circuit down to one and two qubit gates with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SynthesiseTK&lt;/span&gt;&lt;/code&gt; pass to ensure a fair comparison.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.passes&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;DecomposeBoxes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SynthesiseTK&lt;/span&gt;

&lt;span class="n"&gt;test_circ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_gate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;controlled_zzyx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="n"&gt;DecomposeBoxes&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;SynthesiseTK&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Total gate count:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n_gates&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2 qubit gates:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test_circ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n_2qb_gates&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pytket 1.20.1&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="n"&gt;gate&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;103&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;qubit&lt;/span&gt; &lt;span class="n"&gt;gates&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;44&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pytket 1.21.0&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="n"&gt;gate&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;qubit&lt;/span&gt; &lt;span class="n"&gt;gates&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now that’s a big difference! We see pytket 1.21.0 is able to use the underlying &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjuagtionBox&lt;/span&gt;&lt;/code&gt; structure of the Pauli gadget to find a far more efficient implementation.&lt;/p&gt;
&lt;p&gt;The improvement in the number of two qubit entangling gates is particularly nice when we think about running circuits on real quantum hardware. Entangling gates are in general much more noisy than single qubit gates so getting rid of them where possible can be great for boosting the fidelity of our computation.&lt;/p&gt;
&lt;p&gt;The reason for the reduction is that pytket 1.21.0 can simply control on the single Rz in the Pauli gadget. Previously if we wanted to construct a controlled Pauli gadget, pytket would naively construct a controlled version of every single gate in the base Pauli gadget circuit. In version 1.20.1, pytket naively converts all of the CX gates to CCX gates and then has to compile those down to one and two qubit gates with a significant overhead.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;We have shown how we can compile controlled Pauli gadget circuits by making use of the conjugation pattern. This is now logic internal to pytket.&lt;/p&gt;
&lt;p&gt;You can also define your own &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/circuit.html#pytket.circuit.ConjugationBox"&gt;ConjugationBox&lt;/a&gt; by providing a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;compute&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;action&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;uncompute&lt;/span&gt;&lt;/code&gt; operation. Can you think of other cases where this construct would be useful?&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="some-mathematical-details"&gt;
&lt;h2&gt;Some Mathematical Details&lt;/h2&gt;
&lt;p&gt;So why does this work?&lt;/p&gt;
&lt;p&gt;Here we will show that if we have a controlled gate whose base gates fits the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; pattern then it is only necessary to control on the central &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; operation.&lt;/p&gt;
&lt;p&gt;Recall the the form of the conjugation pattern&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
U_c = V \, A \, V^\dagger \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To avoid ambiguity in what follows we will denote a controlled-&lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; operation as &lt;span class="math notranslate nohighlight"&gt;\(C[P]\)&lt;/span&gt; where &lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; is some unitary operator.&lt;/p&gt;
&lt;p&gt;Now we want to show that&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
C[U_c] = C[V \, A \, V^\dagger] = (I \otimes V) C[A] (I \otimes V^\dagger)\, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;A controlled-&lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; operation can be expanded out as follows&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
C[P]= |0\rangle\langle 0| \otimes I + |1\rangle\langle1| \otimes P \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To prove our result let’s take the right hand side of our target equation and expand the &lt;span class="math notranslate nohighlight"&gt;\(C[A]\)&lt;/span&gt; term.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[\begin{split}
\begin{align}
(I \otimes V) C[A] (I \otimes V^\dagger) &amp;amp;= (I \otimes V ) \,( |0\rangle\langle 0| \otimes I + |1\rangle\langle1| \otimes A )\, (I \otimes V^\dagger) \\
&amp;amp;= |0\rangle\langle 0| \otimes \cancelto{I}{V \, I \, V^\dagger} + |1\rangle\langle1| \otimes V \, A \, V^\dagger \\
\implies (I \otimes V) C[A] (I \otimes V^\dagger) &amp;amp;= |0\rangle\langle 0| \otimes I + |1\rangle\langle1| \otimes U_c = C[U_c]
\end{align}
\end{split}\]&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;A. Cowtan, S. Dilkes, R. Duncan, W. Simmons, and
S. Sivarajah, “Phase gadget synthesis for shallow circuits,” in 16th International Conference on Quantum
Physics and Logic 2019. Open Publishing Association,
2019, pp. 213–228&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://docs.quantinuum.com/tket/blog/posts/controlled_gates/"/>
    <summary>Last week brought a new pytket 1.21.0 release! See the changelog for a rundown of all the new features and fixes. This blog will focus on improvements to controlled gates in pytket with the new ConjugationBox feature enabling some key circuit primitives to be implemented far more efficiently. There are also some improvements to how controlled gates are displayed in the circuit renderer.</summary>
    <published>2023-10-24T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://docs.quantinuum.com/tket/blog/posts/september_release_pytket/</id>
    <title>September Release Notes (pytket)</title>
    <updated>2023-09-08T00:00:00+00:00</updated>
    <author>
      <name>Callum Macpherson</name>
    </author>
    <content type="html">&lt;section id="september-release-notes-pytket"&gt;

&lt;p&gt;The September release brings typing improvements, custom control states in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;, equality checking for pytket boxes and more.&lt;/p&gt;
&lt;section id="pytket-1-19-0"&gt;
&lt;h2&gt;pytket 1.19.0&lt;/h2&gt;
&lt;section id="new-features-changelog"&gt;
&lt;h3&gt;New Features (&lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/changelog.html"&gt;Changelog&lt;/a&gt;)&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#typing-improvements-for-compiled-pytket-modules"&gt;&lt;span class="xref myst"&gt;Typing for compiled modules&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#custom-control-states-in-qcontrolbox"&gt;&lt;span class="xref myst"&gt;Custom control states in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#new-conjugationbox-construction"&gt;&lt;span class="xref myst"&gt;New &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; construction&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#equality-checking-for-all-box-types"&gt;&lt;span class="xref myst"&gt;Equality checking implemented for all boxes&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#every-pytket-op-now-has-an-is-clifford-method"&gt;&lt;span class="xref myst"&gt;Every pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; now has an &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;is_clifford&lt;/span&gt;&lt;/code&gt; method&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#qubitpaulitensor-class"&gt;&lt;span class="xref myst"&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; class is now available in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pytket.pauli&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="fixes-1-19-0"&gt;
&lt;h3&gt;Fixes (1.19.0)&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;It is now possible to create an empty &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;BackendResult&lt;/span&gt;&lt;/code&gt; object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Performance fix for symbolic angle squashing.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="update-fixes-1-19-1"&gt;
&lt;h3&gt;Update - Fixes (1.19.1)&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Fix for a regression in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RebaseCustom&lt;/span&gt;&lt;/code&gt;. The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RebaseCustom&lt;/span&gt;&lt;/code&gt; pass would fail to convert circuits containing TK2 gates due to a change released in a previous version. This is now fixed in 1.19.1.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fix to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Circuit.symbol_substitution&lt;/span&gt;&lt;/code&gt; for circuits containing box types that don’t support symbol substitution. Boxes which don’t support symbol substitution include the &lt;a class="reference external" href="https://docs.quantinuum.com/tket/user-guide/manual/manual_circuit.html#boxes-for-unitary-synthesis"&gt;unitary synthesis boxes&lt;/a&gt; and &lt;a class="reference external" href="https://docs.quantinuum.com/tket/user-guide/manual/manual_assertion.html"&gt;assertion boxes&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="typing-improvements-for-compiled-pytket-modules"&gt;
&lt;h3&gt;Typing improvements for compiled pytket modules&lt;/h3&gt;
&lt;p&gt;In previous versions of pytket, type information was not available for any of the compiled modules, which represent a large part of the library.&lt;/p&gt;
&lt;p&gt;For this reason, when using type checkers such as mypy or pyright, it was necessary to use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;#&lt;/span&gt; &lt;span class="pre"&gt;type:&lt;/span&gt; &lt;span class="pre"&gt;ignore&lt;/span&gt;&lt;/code&gt; statements like the following.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt; &lt;span class="c1"&gt;# type: ignore&lt;/span&gt;

&lt;span class="n"&gt;my_circbox&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This also meant that certain type hints and auto complete feature were not available to developers when using compiled modules such as &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pytket.circuit&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pytket.passes&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;pytket now includes type information for all compiled modules via automatically generated type stub files. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;#&lt;/span&gt; &lt;span class="pre"&gt;type:&lt;/span&gt; &lt;span class="pre"&gt;ignore&lt;/span&gt;&lt;/code&gt; statements are no longer needed. This means that developers can use type checkers more freely and take advantage of type hints and autocomplete when working with pytket.&lt;/p&gt;
&lt;p&gt;Note that using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;#&lt;/span&gt; &lt;span class="pre"&gt;type:&lt;/span&gt; &lt;span class="pre"&gt;ignore&lt;/span&gt;&lt;/code&gt; does not suppress type information if it is available. This means that type checking runs that were previously passing may now fail if the usage of objects from compiled modules is deemed improper by the type checker.&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;In order to use some of the &lt;a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/extensions.html"&gt;pytket extension modules&lt;/a&gt; with pytket 1.19.0 or newer, you will need to use a version of the extension package that was released in September 2023 or later. This is due to the typing changes in the pytket 1.19.0 release.&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="custom-control-states-in-qcontrolbox"&gt;
&lt;h3&gt;Custom control states in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; provides an interface for users to define controlled unitary operations.&lt;/p&gt;
&lt;p&gt;Given a pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; we can define a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; as follows&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="n"&gt;s_gate_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;cccs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s_gate_op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# define a CCCS gate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Here we have defined &lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate controlled on 3 qubits. This means that an S will be applied when all 3 control qubits are in the &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt; state.&lt;/p&gt;
&lt;p&gt;However prior to the 1.19 release a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; could only be defined using the “all &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;” control state.&lt;/p&gt;
&lt;p&gt;This has now changed and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; now accepts a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;control_state&lt;/span&gt;&lt;/code&gt; argument. If no &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;control_state&lt;/span&gt;&lt;/code&gt; argument is provided then the default “all &lt;span class="math notranslate nohighlight"&gt;\(|1\rangle\)&lt;/span&gt;” state is used. Lets define a controlled-&lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate with a control state of &lt;span class="math notranslate nohighlight"&gt;\(|010\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="n"&gt;s_gate_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;custom_cccs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s_gate_op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;control_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
&lt;span class="c1"&gt;# Equivalent to the above (using an integer control_state)&lt;/span&gt;
&lt;span class="c1"&gt;# custom_cccs = QControlBox(op, 3, control_state=2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now the &lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate will be applied to the target when the three control qubits are in the &lt;span class="math notranslate nohighlight"&gt;\(|010\rangle\)&lt;/span&gt; state.&lt;/p&gt;
&lt;p&gt;These sorts of gates appear frequently in quantum algorithms. Here is a simple example of an LCU (Linear combination of unitaries) circuit.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://docs.quantinuum.com/tket/blog/_images/lcu_diagram.png" /&gt;&lt;/p&gt;
&lt;p&gt;This circuit can be used to calculate the expectation value of the sum of &lt;span class="math notranslate nohighlight"&gt;\(U_a\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(U_b\)&lt;/span&gt;. Here the empty circle in the second control gates denotes a “0-controlled” gate.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
 \langle U_a + U_b \rangle =  \langle  \psi| U_{a} + U_{b} | \psi \rangle
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Suppose we create a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CircBox&lt;/span&gt;&lt;/code&gt; for the &lt;span class="math notranslate nohighlight"&gt;\(U_a\)&lt;/span&gt; operation. We can then construct a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt; for the 0-controlled &lt;span class="math notranslate nohighlight"&gt;\(U_a\)&lt;/span&gt; as follows&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;

&lt;span class="n"&gt;ub_box&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 

&lt;span class="n"&gt;zero_controlled_ub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QControlBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ub_box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;control_state&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="every-pytket-op-now-has-an-is-clifford-method"&gt;
&lt;h3&gt;Every pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; now has an &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;is_clifford&lt;/span&gt;&lt;/code&gt; method&lt;/h3&gt;
&lt;p&gt;Clifford circuits are an important class of quantum circuits known to exhibit efficient classical simulation.&lt;/p&gt;
&lt;p&gt;A Clifford gate is an element of the Clifford group which can be generated by the &lt;span class="math notranslate nohighlight"&gt;\(\{H, S, CX\}\)&lt;/span&gt; operations. Such operations map Pauli operations &lt;span class="math notranslate nohighlight"&gt;\(P\)&lt;/span&gt; to other Pauli operations &lt;span class="math notranslate nohighlight"&gt;\(P'\)&lt;/span&gt;  when conjugated as follows&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
P' = C \, P \, C^\dagger \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;For instance a Pauli &lt;span class="math notranslate nohighlight"&gt;\(X\)&lt;/span&gt; can be transformed to a Pauli &lt;span class="math notranslate nohighlight"&gt;\(Z\)&lt;/span&gt; by conjugating with a Hadamard Gate.&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
X = H \, Z \, H^\dagger = H \, Z \, H \, .
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Given a pytket &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op&lt;/span&gt;&lt;/code&gt; we could check whether it was a Clifford type operation with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op.is_clifford_type&lt;/span&gt;&lt;/code&gt; method.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OpType&lt;/span&gt;

&lt;span class="n"&gt;s_gate_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s_gate_op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_clifford_type&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This returns &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;True&lt;/span&gt;&lt;/code&gt;, the &lt;span class="math notranslate nohighlight"&gt;\(S\)&lt;/span&gt; gate is a well known Clifford gate.&lt;/p&gt;
&lt;p&gt;However &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op.is_clifford_type&lt;/span&gt;&lt;/code&gt; is limited as it only checks whether the underlying &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;OpType&lt;/span&gt;&lt;/code&gt; is Clifford. This check would not be able to handle the case of parameterised gates that have Clifford angles.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;rz_clifford_op&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OpType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Rz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;rz_clifford_op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_clifford_type&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Here we have defined the Rz op with the &lt;span class="math notranslate nohighlight"&gt;\(1\)&lt;/span&gt; rotation parameter (equivalent to 1 half turn).
The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;is_clifford_type&lt;/span&gt;&lt;/code&gt; method will return &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/code&gt; here as the Rz gate is not in general a Clifford gate.&lt;/p&gt;
&lt;p&gt;However in pytket 1.19 we can now use the more general &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Op.is_clifford()&lt;/span&gt;&lt;/code&gt; method.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;rz_clifford_op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_clifford&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This method will now correctly identify the Rz gate as a Clifford by checking whether the parameter is a Clifford angle.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="qubitpaulitensor-class"&gt;
&lt;h3&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; class&lt;/h3&gt;
&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; class is now exposed to pytket. A &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliTensor&lt;/span&gt;&lt;/code&gt; is defined using a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QubitPauliString&lt;/span&gt;&lt;/code&gt; paired with a complex coefficient.&lt;/p&gt;
&lt;p&gt;This allows phase to be tracked when using the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;UnitaryTableau&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="equality-checking-for-all-box-types"&gt;
&lt;h3&gt;Equality checking for all box types&lt;/h3&gt;
&lt;p&gt;A pytket box represents a higher level subroutine that can be added to a quantum circuit. For more on the different types of box available in pytket, read the &lt;a class="reference internal" href="#../user-guide/manual/manual_circuit.html#boxes"&gt;&lt;span class="xref myst"&gt;user manual section&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After the pytket 1.19 release, every box type now allows for equivalence checking.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pytket.circuit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;

&lt;span class="n"&gt;ghz_circ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Circuit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;GHZ&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Construct two equivalent CircBox objects&lt;/span&gt;
&lt;span class="n"&gt;box1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ghz_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;box2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CircBox&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ghz_circ&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;box1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;box2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This equality check will now return &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;True&lt;/span&gt;&lt;/code&gt; in pytket 1.19. In older versions of pytket, the equality check would return &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Being able to test for equivalence is useful for testing purposes. We can validate the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CircBox&lt;/span&gt;&lt;/code&gt; without decomposing it or having to defer to the underlying circuit with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CircBox.get_circuit()&lt;/span&gt;&lt;/code&gt; method.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="new-conjugationbox-construction"&gt;
&lt;h3&gt;New &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; construction&lt;/h3&gt;
&lt;p&gt;Another enhancement related to controlled gates is the new &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; feature. This allows us to find efficient decompositions for controlled gates when our base gate &lt;span class="math notranslate nohighlight"&gt;\(U_{\text{conj}}\)&lt;/span&gt; is of the form&lt;/p&gt;
&lt;div class="math-wrapper docutils container"&gt;
&lt;div class="math notranslate nohighlight"&gt;
\[
\begin{equation}
U_\text{conj} = C \, A \, C^\dagger
\end{equation}
\]&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Where &lt;span class="math notranslate nohighlight"&gt;\(U_{\text{conj}},\, A\)&lt;/span&gt; and &lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt; are unitary operations.&lt;/p&gt;
&lt;p&gt;This compute (&lt;span class="math notranslate nohighlight"&gt;\(C\)&lt;/span&gt;), action (&lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt;), uncompute (&lt;span class="math notranslate nohighlight"&gt;\(C^\dagger\)&lt;/span&gt;) pattern occurs frequently in various applications of quantum computing. It can be shown that to construct a controlled &lt;span class="math notranslate nohighlight"&gt;\(U_{\text{conj}}\)&lt;/span&gt; operation it is only necessary to control on the central &lt;span class="math notranslate nohighlight"&gt;\(A\)&lt;/span&gt; operation.&lt;/p&gt;
&lt;p&gt;Enhancements to this feature will be added in a subsequent release to handle &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ConjugationBox&lt;/span&gt;&lt;/code&gt; objects inside &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;QControlBox&lt;/span&gt;&lt;/code&gt;, enabling more efficient compilation.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://docs.quantinuum.com/tket/blog/posts/september_release_pytket/"/>
    <summary>The September release brings typing improvements, custom control states in QControlBox, equality checking for pytket boxes and more.</summary>
    <published>2023-09-08T00:00:00+00:00</published>
  </entry>
</feed>
