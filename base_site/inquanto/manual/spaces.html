<!doctype html>
<html class="no-js" lang="en" data-content_root="">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YPQ1FTGDL3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-YPQ1FTGDL3');
    </script>
    <link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Ansatzes" href="ansatzae_overview.html" /><link rel="prev" title="Noise mitigation" href="errmit.html" />

    <link rel="shortcut icon" href="../_static/quantinuum_favicon.svg"/><!-- Generated with Sphinx 6.2.1 and Furo 2024.08.06 -->
        <title>Spaces, Operators, and States - InQuanto 4.2.0</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=04c057b233f3c8d71940eee6080f658a04e2027d" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=cf727022eb7470bc603c08d2e55c3247faec75c9" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style>
<link rel="stylesheet" href="../_static/tokens.css"/>
<link rel="stylesheet" href="../_static/styles.css"/>
<link rel="stylesheet" href="../_static/tailwind.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="preload"
as="style">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">

<style>  
  .sidebar-sticky {
    top: calc(3.5rem - 0px);
    height: calc(100vh - 3.5rem);
  }
  
  @media (min-width: 97em) {
    html {
      font-size: 100% !important;
    }
  }
  
</style>
</head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>
<!-- <script type="text/javascript" src="../_static/syncTheme.global.js" ></script> -->
 <!--Force light mode -->
 <script>document.body.setAttribute('data-theme','light')</script>
<nav style="position:fixed;top:0;z-index:1021;width:100%;">
    <div class="nexus-nav"></div>
</nav>
<script type="text/javascript" src="../_static/injectNav.global.js"></script>
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">InQuanto 4.2.0</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/inquanto_short_logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">InQuanto 4.2.0</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction/overview.html">What is InQuanto?</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../introduction/installation.html">Installation</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Installation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction/system_requirements.html">System Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../introduction/troubleshooting.html">Troubleshooting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/quickstart.html">Quick-start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="howto.html">How to use InQuanto</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="algorithms_overview.html">Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Algorithms</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="algorithms/variational_overview.html">Variational Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Variational Algorithms</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="algorithms/algorithms_vqe.html">Variational Quantum Eigensolver <code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmVQE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="algorithms/algorithms_vqd.html">Variational Quantum Deflation <code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmVQD</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="algorithms/algorithms_adapt.html">ADAPT-VQE</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="algorithms/non_variational_overview.html">Non-variational and Phase Estimation algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Non-variational and Phase Estimation algorithms</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="algorithms/algorithms_qse.html">Quantum Subspace Expansion <code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmQSE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="algorithms/algorithms_sceom.html">Quantum Self Consistent Equation of Motion <code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmSCEOM</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="algorithms/qpe_canonical.html">Canonical Quantum Phase Estimation <code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmDeterministicQPE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="algorithms/qpe_iterative.html">Iterative Phase Estimation Algorithms</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="algorithms/time_evolution_overview.html">Time evolution algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Time evolution algorithms</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="algorithms/te_vqs.html"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmVQS</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmMcLachlanRealTime</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">AlgorithmMcLachlanImagTime</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="computables_overview.html">Computables</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of Computables</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="computables/basic_usage.html">Basic Usage and Composability</a></li>
<li class="toctree-l2"><a class="reference internal" href="computables/evaluating_w_protocols.html">Evaluating Computables with Protocols</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="computables/composite_computables.html">Composite Computables</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Composite Computables</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="computables/greens_function.html">Krylov subspace &amp; Green’s functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="computables/rdms.html">Reduced Density Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="computables/overlap_matrix.html">Overlap Matrices &amp; Non-Orthogonal Subspaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="computables/primitives.html">Primitive Computables</a></li>
<li class="toctree-l2"><a class="reference internal" href="computables/custom_computables.html">Custom Computables &amp; Partial Evaluations</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="protocols_overview.html">Protocols</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of Protocols</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="protocols/expval.html">Protocols for expectation values</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols/overlap_squared.html">Protocols for overlap squared</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols/overlap.html">Protocols for overlaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols/derivative.html">Protocols for derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols/other.html">Other averaging protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols/phase_est.html">Protocols for Phase Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols/resource_estimation.html">Resource estimation</a></li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="errmit.html">Noise mitigation</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Spaces, Operators, and States</a></li>
</ul>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="ansatzae_overview.html">Ansatzes</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of Ansatzes</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="ansatze/ucc_family.html">The UCC Family</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/chemically_aware.html">Chemically Aware Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/trotter_ansatz.html">Trotter Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/fermion_state_exp.html">Fermionic Exponentiated Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/circuit_ansatz.html">Circuit Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/composed_ansatz.html">Composed Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/hea.html">Hardware Efficient Ansatz</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/multi_configurational.html">Multiconfiguration States Using Givens Rotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ansatze/basis_rotation.html">Real Basis Rotation Ansatzes</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="symmetry.html">Symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="geometry.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="minimizers.html">Classical Minimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmet.html">Density Matrix Embedding Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="express.html">Express</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials &amp; Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorial_overview.html">Tutorials</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorials/tutorial_overview.html#core-tutorials">Core Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of Core Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_vqe_1.html">A basic VQE simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_vqe_2.html">Extended VQE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_vqd.html">Variational Quantum Deflation for excited states</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_viz.html">Visualization with inquanto-nglview</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorials/tutorial_overview.html#backend-tutorials">Backend Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of Backend Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/backends_overview.html">Backends Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_Nexus_1.html"><b>Tutorial: InQuanto + qnexus</b></a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_htut_Aer_H2.html">Running on the Aer simulator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_htut_qsys_H2.html">Running on Quantinuum Hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_htut_qsys_l%2Br.html">Quantinuum Systems -  Launching circuits and retrieving results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_htut_qsys_qse.html">Quantinuum Systems -  Quantum Subspace Expansion</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorials/tutorial_overview.html#case-study-tutorials-fe4n2">Case Study Tutorials - Fe4N2</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of Case Study Tutorials - Fe4N2</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_fe4n2_1.html">Fe4N2 - 1 - system construction with AVAS and CASSCF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_fe4n2_2.html">Fe4N2 - 2 - circuit construction with ADAPT-VQE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_fe4n2_3.html">Fe4N2 - 3 - calculations on Quantinuum hardware</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorials/tutorial_overview.html#fragmentation-tutorials">Fragmentation Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of Fragmentation Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_dmet.html">Tackling larger systems with fragmentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_wft_dft.html">Projection-based embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_nevpt2_AC0.html">NEVPT2 and AC0 energy corrections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/InQ_tut_wft_dft_2.html">Projection-based embedding with energy corrections</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/examples_overview.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extensions User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../extensions/extensions-overview.html">Extensions overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extensions/inquanto-nexus.html">InQuanto-Nexus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extensions/inquanto-pyscf.html">InQuanto-PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extensions/inquanto-nglview.html">InQuanto-NGLView</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extensions/inquanto-phayes.html">InQuanto-Phayes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../extensions/extensions_examples.html">Extensions examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/inquanto_api_intro.html">InQuanto</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of InQuanto</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/algorithms.html">inquanto.algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/ansatz.html">inquanto.ansatzes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/computables.html">inquanto.computables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/core.html">inquanto.core</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/embeddings.html">inquanto.embeddings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/express.html">inquanto.express</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/geometry.html">inquanto.geometries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/mappings.html">inquanto.mappings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/minimizers.html">inquanto.minimizers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/operators.html">inquanto.operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/protocols.html">inquanto.protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/spaces.html">inquanto.spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/states.html">inquanto.states</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/inquanto/symmetry.html">inquanto.symmetry</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/inquanto-ext_api_intro.html">InQuanto-Extensions</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of InQuanto-Extensions</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/extensions/inquanto-nexus_api.html">InQuanto-Nexus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/extensions/inquanto-pyscf_api.html">InQuanto-PySCF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/extensions/inquanto-nglview_api.html">InQuanto-NGLView</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/extensions/inquanto-phayes.html">InQuanto-Phayes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/extensions/inquanto-cutensornet_api.html">InQuanto-cuTensorNet</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../misc/changelog.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/contact.html">Contact Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/cite.html">How to cite InQuanto</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/licence.html">License and Notices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/opensource.html">Open-source Attribution</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          

<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="spaces-operators-and-states">
<span id="spaces"></span><h1>Spaces, Operators, and States<a class="headerlink" href="#spaces-operators-and-states" title="Permalink to this heading">¶</a></h1>
<p>The use of quantum computers for tackling problems in quantum chemistry
involves a wide variety of quantum mechanical structures. Many of these
are shared with quantum chemistry problems studied with classical
computers. For example, the electronic Hamiltonian may be considered a
second-quantized operator acting on a fermionic Hilbert space. However,
quantum computing approaches often require objects and formalisms that
are atypical to “conventional” quantum chemistry – for instance,
fermionic operators and states must be mapped to operators acting on and states within a qubit Hilbert space.</p>
<p>InQuanto provides options for representing each of these objects.
Broadly, three core types of objects are used - InQuanto operator and
state classes represent operators and states within a given Hilbert
space. Space objects (chiefly <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> and <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.QubitSpace" title="inquanto.spaces.QubitSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitSpace</span></code></a>) can
be used to describe specific Hilbert spaces and then generate these
states and operators.  The relationship between these objects is depicted in <a class="reference internal" href="#fig-spaces-overview"><span class="std std-numref">Fig. 22</span></a>.</p>
<figure class="align-center" id="fig-spaces-overview">
<img alt="../_images/operators.svg" src="../_images/operators.svg" /><figcaption>
<p><span class="caption-number">Fig. 22 </span><span class="caption-text">A schematic of the vector space, state and operator classes in InQuanto.  Spaces generate operators and states; fermion-to-qubit mappings transform fermionic states and operators to qubit states and operators.</span><a class="headerlink" href="#fig-spaces-overview" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>We first discuss <a class="reference internal" href="#fermion-spaces"><span class="std std-ref">fermionic</span></a>
and <a class="reference internal" href="#qubit-spaces"><span class="std std-ref">qubit</span></a> spaces and how operators and states can
be <a class="reference internal" href="#qubit-mapping"><span class="std std-ref">mapped</span></a> between the two. An option for
parafermionic <span id="id1">[<a class="reference internal" href="../misc/bibliography.html#id33" title="L.-A. Wu and D. A. Lidar. Qubits as parafermions. Journal of Mathematical Physics, 43(9):4506-4525, 2002. URL: https://doi.org/10.1063/1.1499208, arXiv:https://doi.org/10.1063/1.1499208, doi:10.1063/1.1499208.">10</a>]</span> spaces is also provided by the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.ParaFermionSpace" title="inquanto.spaces.ParaFermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParaFermionSpace</span></code></a> object.  This mapping is
described in the <a class="reference internal" href="algorithms/algorithms_adapt.html#iqeb"><span class="std std-ref">Iterative Qubit-Excitation Based VQE algorithm</span></a> section. We also consider
<a class="reference internal" href="#integral-operators"><span class="std std-ref">integral operators</span></a> - classes for the
efficient manipulation of molecular orbital integral tensors. Finally,
we consider <a class="reference internal" href="#orbital-transformation"><span class="std std-ref">orbital transformers</span></a> and
optimization – several InQuanto classes for the convenient
manipulation of molecular orbitals bases.</p>
<section id="fermionic-spaces">
<span id="fermion-spaces"></span><h2>Fermionic Spaces<a class="headerlink" href="#fermionic-spaces" title="Permalink to this heading">¶</a></h2>
<p>Given a system of <span class="math notranslate nohighlight">\(N\)</span> electrons described by an orthonormal basis of <span class="math notranslate nohighlight">\(Q\)</span> molecular spin-orbitals, or
momentum space modes, where <span class="math notranslate nohighlight">\(Q \geq N\)</span>, one can construct a fermionic Fock space <span id="id2">[<a class="reference internal" href="../misc/bibliography.html#id8" title="Trygve Helgaker, Poul Jørgensen, and Jeppe Olsen. Molecular Electronic-Structure Theory. Wiley, Chichester ; New York, 2000. ISBN 978-0-471-96755-2 978-1-118-53147-1.">5</a>]</span>, or “fermion
space”. Each basis vector of this abstract vector space corresponds to an occupation number (ON) vector</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-0">
<div class="math notranslate nohighlight" id="equation-manual-spaces-0">
<span class="eqno">(67)<a class="headerlink" href="#equation-manual-spaces-0" title="Permalink to this equation">¶</a></span>\[|\boldsymbol{\eta}\rangle = |\eta_0, \eta_1, ..., \eta_P, ..., \eta_{Q-1} \rangle\]</div>
</div>
<p>where an occupation number <span class="math notranslate nohighlight">\(\eta_P = 1\)</span> (<span class="math notranslate nohighlight">\(0\)</span>) if spin-orbital <span class="math notranslate nohighlight">\(P\)</span> is occupied (unoccupied). Each
ON vector represents a canonically ordered <span class="math notranslate nohighlight">\(N\)</span>-electron Slater determinant. A fermion space is an abstract
linear vector space equipped with the usual properties of an inner product and resolution of identity, for a given set
of spin-orbitals or modes. An arbitrary vector in this space corresponds to a linear combination of ON vectors</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-1">
<div class="math notranslate nohighlight" id="equation-manual-spaces-1">
<span class="eqno">(68)<a class="headerlink" href="#equation-manual-spaces-1" title="Permalink to this equation">¶</a></span>\[|\boldsymbol{\psi}\rangle = \sum_{\boldsymbol{\eta}} \psi_{\boldsymbol{\eta}} |\boldsymbol{\eta}\rangle\]</div>
</div>
<p>if the spin-orbitals or modes used to construct the ON vectors are orthonormal, such that the ON vectors obey the relation</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-2">
<div class="math notranslate nohighlight" id="equation-manual-spaces-2">
<span class="eqno">(69)<a class="headerlink" href="#equation-manual-spaces-2" title="Permalink to this equation">¶</a></span>\[\langle\boldsymbol{\eta}'|\boldsymbol{\eta}\rangle = \prod_{P=0}^{Q-1} \delta_{\eta'_P, \eta_P}\]</div>
</div>
<p>This is a useful feature of fermion spaces: a well defined but zero overlap between ON vectors with different
values of <span class="math notranslate nohighlight">\(N = \sum_{P=0}^{Q-1} \eta_P\)</span> and <span class="math notranslate nohighlight">\(N' = \sum_{P=0}^{Q-1} \eta'_P\)</span> allows for a consistent
treatment of systems with different numbers of electrons. Thus the ON vectors form an orthonormal basis in the
<span class="math notranslate nohighlight">\(2^Q\)</span>-dimensional fermion space, which in principle can be decomposed into a direct sum of fermionic subspaces
<span class="math notranslate nohighlight">\(\mathcal{F}(Q, N)\)</span>, where each subspace represents a different number of electrons distributed over the
<span class="math notranslate nohighlight">\(Q\)</span> spin-orbitals.</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-3">
<div class="math notranslate nohighlight" id="equation-manual-spaces-3">
<span class="eqno">(70)<a class="headerlink" href="#equation-manual-spaces-3" title="Permalink to this equation">¶</a></span>\[\mathcal{F}(Q) = \bigoplus_{N=0}^Q \mathcal{F}(Q, N)\]</div>
</div>
<p>The dimension of each <span class="math notranslate nohighlight">\(\mathcal{F}(Q, N)\)</span> subspace is equal to the number of terms in the FCI expansion
<span class="math notranslate nohighlight">\(\binom{Q}{N}\)</span>, such that the exact (FCI) wavefunction for <span class="math notranslate nohighlight">\(N\)</span> electrons (in a given basis) can be expressed
as a vector in <span class="math notranslate nohighlight">\(\mathcal{F}(Q, N)\)</span>.</p>
<p>Anticommuting creation and annihilation operators act on the fermion space as linear maps between vectors within the space.  From these
operators, one- and two-body interactions can be defined, along with the fermionic ON vectors, and thus the entire fermionic
problem can be described once the <span class="math notranslate nohighlight">\(N\)</span>-electron subspace is specified. In InQuanto, this logic is followed in the
<a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> class which represents the fermionic Fock space <span class="math notranslate nohighlight">\(\mathcal{F}(Q)\)</span>, and contains related
utilities for the construction of fermionic interaction operators (represented by the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> class) and
ON vectors (represented by the <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> class). In the next subsection
<a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> is discussed, while <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> and <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> are covered in later sections.</p>
<section id="the-fermionspace-class">
<h3>The <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> Class<a class="headerlink" href="#the-fermionspace-class" title="Permalink to this heading">¶</a></h3>
<p>This class provides a range of tools related to the fermionic Fock space. These tools include the definition of the
space itself, and operations on this space related to the generation of fermionic operators and for specification of
occupations.  The <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> class represents a fermionic Hilbert space, maintaining consistent indexing of spin-orbitals.  It incorporates the fermionic anti-commutation algebra in the logic of the class, allowing for the generation of various fermionic quantum operators acting on a given Hilbert space.</p>
<p>Various fermionic quantum operators can be constructed from the methods in this class.
These include the number operators, spin operators, one- and two-body operators in various
forms, and the anti-Hermitian operators needed for unitary coupled cluster ansatz generation. For example,
the UCC terms for minimal basis H<sub>2</sub>  (with 4 spin-orbitals) are defined as follows:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.spaces</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionSpace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span>

<span class="c1"># create a FermionSpace object for, say, H2</span>
<span class="n">space</span> <span class="o">=</span> <span class="n">FermionSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">FermionState</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c1"># with the state and space objects we can construct operators using native functions, for example:</span>
<span class="n">singles</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">construct_single_ucc_operators</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="n">doubles</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">construct_double_ucc_operators</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="n">uccsd_excitations</span> <span class="o">=</span> <span class="n">singles</span> <span class="o">+</span> <span class="n">doubles</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of uccsd excitations for minimal basis h2:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uccsd_excitations</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>number of uccsd excitations for minimal basis h2: 3
</pre></div>
</div>
</div>
</div>
<p>In this case, the occupations specified by <code class="code docutils literal notranslate"><span class="pre">state</span></code> are needed to construct the UCC operators, though this is not always required depending on the operators being generated. The operators are returned as <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> objects
(<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> and <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> are discussed in more detail later). Several types of operators can be generated by the various methods of <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a>, including various forms of number operators, excitation operators and symmetry operators.  An exhaustive list of these operators can be found in <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">the</span> <span class="pre">API</span> <span class="pre">reference</span></code></a>.</p>
<p>Once the space and
occupations are defined, information relevant to the ON vector can be displayed using the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace.print_state" title="inquanto.spaces.FermionSpace.print_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_state()</span></code></a> method:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.spaces</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionSpace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span>

<span class="c1"># create a FermionSpace object for, say, H2</span>
<span class="n">space</span> <span class="o">=</span> <span class="n">FermionSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">FermionState</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fermionic fock state:&quot;</span><span class="p">)</span>
<span class="n">space</span><span class="o">.</span><span class="n">print_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>fermionic fock state:
 0 0a         :  1    
 1 0b         :  1    
 2 1a         :  0    
 3 1b         :  0    
</pre></div>
</div>
</div>
</div>
<p>The left-most column refers to spin-orbital indexes, the next column shows the spatial orbital indexes with the
alpha (<code class="code docutils literal notranslate"><span class="pre">a</span></code>) and beta (<code class="code docutils literal notranslate"><span class="pre">b</span></code>) spin labels, while the right-most column shows the occupation of each spin-orbital.</p>
<p>Typically, operators generated using the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> methods will preserve particle number and spin conservation symmetries.  In addition to these, <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> can also optionally handle point group symmetry information. By passing in point group symmetries when
instantiating the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> class object, we can generate only those excitations that are non-zero by
symmetry. Below, the single excitations of H<sub>2</sub>  are symmetry forbidden, leaving only one double.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.spaces</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionSpace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.symmetry</span><span class="w"> </span><span class="kn">import</span> <span class="n">PointGroup</span>

<span class="c1"># create a FermionSpace object for, say, H2</span>
<span class="n">space</span> <span class="o">=</span> <span class="n">FermionSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">FermionState</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c1"># we can also pass symmetry information to remove redundant excitations</span>
<span class="n">space</span> <span class="o">=</span> <span class="n">FermionSpace</span><span class="p">(</span>
    <span class="mi">4</span><span class="p">,</span> <span class="n">point_group</span><span class="o">=</span><span class="n">PointGroup</span><span class="p">(</span><span class="s2">&quot;D2h&quot;</span><span class="p">),</span> <span class="n">orb_irreps</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Ag&quot;</span><span class="p">,</span> <span class="s2">&quot;Ag&quot;</span><span class="p">,</span> <span class="s2">&quot;B1u&quot;</span><span class="p">,</span> <span class="s2">&quot;B1u&quot;</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">singles</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">construct_single_ucc_operators</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="n">doubles</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">construct_double_ucc_operators</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="n">uccsd_excitations</span> <span class="o">=</span> <span class="n">singles</span> <span class="o">+</span> <span class="n">doubles</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of allowed uccsd excitations for minimal basis h2:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uccsd_excitations</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>number of allowed uccsd excitations for minimal basis h2: 1
</pre></div>
</div>
</div>
</div>
<p>This potentially reduces the size of the problem; for example, the number of parameters in variational algorithms like VQE.  When a <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> object is generated from a driver, it will typically include point group information if the driver utilized this information in performing precursor classical computation.  The <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> classes can be used to generate explicit operator representations of the symmetries of the system with the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace.symmetry_operators_z2" title="inquanto.spaces.FermionSpace.symmetry_operators_z2"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetry_operators_z2()</span></code></a> method - usage of this is detailed in the <span class="xref std std-ref">symmetry</span> section.</p>
</section>
<section id="fermion-operators-states">
<span id="id3"></span><h3>Fermion Operators &amp; States<a class="headerlink" href="#fermion-operators-states" title="Permalink to this heading">¶</a></h3>
<p>In second quantization, operators acting on fermionic states are represented by linear combinations and tensor products of creation and annihilation operators.  These obey the anticommutation relations</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-4">
<div class="math notranslate nohighlight" id="equation-manual-spaces-4">
<span class="eqno">(71)<a class="headerlink" href="#equation-manual-spaces-4" title="Permalink to this equation">¶</a></span>\[ \begin{align}\begin{aligned}\{\hat{f}^\dagger_P, \hat{f}^\dagger_{P'}\} &amp;= 0\\\{\hat{f}_P, \hat{f}_{P'}\} &amp;= 0\\\{\hat{f}^\dagger_P, \hat{f}_{P'}\} &amp;= \delta_{P, P'}\end{aligned}\end{align} \]</div>
</div>
<p>Where <span class="math notranslate nohighlight">\(\{\hat{A}, \hat{B}\} = \hat{A}\hat{B} + \hat{B}\hat{A}\)</span>. Mathematically, these operators couple ON vectors
belonging to different subspaces <span class="math notranslate nohighlight">\(\mathcal{F}(Q, N)\)</span>. Thus, a given arrangement of occupations can be used to
build an ON vector by applying a product of creation operators to the vacuum state, such that creation operators are
only applied to spin-orbitals or modes that should be unoccupied</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-5">
<div class="math notranslate nohighlight" id="equation-manual-spaces-5">
<span class="eqno">(72)<a class="headerlink" href="#equation-manual-spaces-5" title="Permalink to this equation">¶</a></span>\[|\boldsymbol{\eta}\rangle = \prod_{P=0}^{Q-1} (\hat{f}^\dagger_P)^{\eta_P} |0_{0}, ... , 0_{P}, ... , 0_{Q-1}\rangle\]</div>
</div>
<p>In InQuanto, vectors in <span class="math notranslate nohighlight">\(\mathcal{F}(Q, N)\)</span> space are represented by <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> objects.  Individual basis states without coefficients are represented by <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionStateString" title="inquanto.states.FermionStateString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionStateString</span></code></a> objects.  A <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionStateString" title="inquanto.states.FermionStateString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionStateString</span></code></a> functions as a dictionary mapping spin-orbital indices represented as integers, to occupation numbers (also represented as integers, of values <code class="code docutils literal notranslate"><span class="pre">0</span></code> or <code class="code docutils literal notranslate"><span class="pre">1</span></code>). For example, for an ON vector of four spin-orbitals, with spin-orbitals indexed <code class="code docutils literal notranslate"><span class="pre">0</span></code> and <code class="code docutils literal notranslate"><span class="pre">1</span></code> occupied, and spin-orbitals indexed <code class="code docutils literal notranslate"><span class="pre">3</span></code> and <code class="code docutils literal notranslate"><span class="pre">4</span></code> unoccupied:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionStateString</span>
<span class="n">on_vector</span> <span class="o">=</span> <span class="n">FermionStateString</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="n">on_vector</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>{0: 1, 1: 1, 3: 0, 4: 0}
</pre></div>
</div>
</div>
</div>
<p>A simple list of occupation numbers may also be provided to the constructor, as a convenient alternative.  In this case, a default register of fermionic modes will be assumed, indexed from <span class="math notranslate nohighlight">\([0,N)\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the length of the provided list (i.e. the number of spin-orbitals)</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionStateString</span>
<span class="n">on_vector</span> <span class="o">=</span> <span class="n">FermionStateString</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">on_vector</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>{0: 1, 1: 1, 2: 0, 3: 0}
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The use of a dictionary with integer keys – as opposed to a simple <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> – allows for the representation of spin-orbitals with discontinuous indices.  This may be useful when representing states which are elements of different Hilbert spaces.  It also allows for a uniform interface with classes which represent states wherein the modes are represented by more complex objects, as in the case of <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.QubitState" title="inquanto.states.QubitState"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitState</span></code></a> below.</p>
</div>
<p>The <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> then represents the state as a dictionary, with
the <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionStateString" title="inquanto.states.FermionStateString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionStateString</span></code></a> objects (occupation configurations) as keys, and
numerical quantities (configuration coefficients) as values.  Typically, this will be constructed with a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> giving such a mapping:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span><span class="p">,</span> <span class="n">FermionStateString</span>

<span class="n">on_vector</span> <span class="o">=</span> <span class="n">FermionStateString</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">FermionState</span><span class="p">({</span><span class="n">on_vector</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(1.0, {0: 1, 1: 1, 2: 0, 3: 0})
</pre></div>
</div>
</div>
</div>
<p>If a simple <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> representing a single basis state with unit coefficient is required, a convenient
alternative for construction is also provided.  A list of integer
occupation values may be directly passed to the constructor, following the logic of the <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionStateString" title="inquanto.states.FermionStateString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionStateString</span></code></a> above:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="o">=</span> <span class="n">FermionState</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(1.0, {0: 1, 1: 1, 2: 0, 3: 0})
</pre></div>
</div>
</div>
</div>
<p>A <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> object can also be generated as a method of <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a>, by passing the
occupation list as an argument.  This allows for consistent spin-orbital indexing determined by the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.FermionSpace" title="inquanto.spaces.FermionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code></a> instance.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.spaces</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionSpace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span>

<span class="n">space</span> <span class="o">=</span> <span class="n">FermionSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">generate_occupation_state_from_list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p><a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> objects may be operated on with standard linear algebraic operations to return
new <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> objects, and may be iterated over.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_state</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">state</span> <span class="o">+</span> <span class="n">FermionState</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_state</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(2.0, {0: 1, 1: 1, 2: 0, 3: 0})
(1.0, {0: 0, 1: 0, 2: 1, 3: 1})
</pre></div>
</div>
</div>
</div>
<p>In addition to representing fermionic states, InQuanto has capabilities for representing operators acting within fermionic Hilbert spaces.
Analogously to <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionStateString" title="inquanto.states.FermionStateString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionStateString</span></code></a>, the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorString" title="inquanto.operators.FermionOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorString</span></code></a> represents a single unweighted
string of fermionic creation and annihilation operators.  A <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorString" title="inquanto.operators.FermionOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorString</span></code></a>
may be created with a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of pairs of integers, in which the first integer represents the spin-orbital or mode and the second
integer is 1 (0) for creation (annihilation) operators.  For example, consider an excitation operator in which an
electron is annihilated from spin-orbital 2 and created on spin-orbital 3 ( <span class="math notranslate nohighlight">\(\hat{f}^\dagger_3\hat{f}_2\)</span> ):</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionOperator</span><span class="p">,</span> <span class="n">FermionOperatorString</span>

<span class="n">f_op_str</span> <span class="o">=</span> <span class="n">FermionOperatorString</span><span class="p">(((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_op_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>F3^ F2 
</pre></div>
</div>
</div>
</div>
<p>For convenience, it is also possible to create such an object from string input:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f_op_str</span> <span class="o">=</span> <span class="n">FermionOperatorString</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;F3^ F2&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_op_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>F3^ F2 
</pre></div>
</div>
</div>
</div>
<p>Similarly to <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a>, fermionic operators are then represented by <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a>.  This stores the coefficients of each sequence of creation/annihilation operators as a dictionary, in which the keys
are <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorString" title="inquanto.operators.FermionOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorString</span></code></a> objects and the values are their coefficients.  It may be created through providing the
constructor with such a dictionary.  Again, a convenient alternative is provided for the construction of an operator comprised of a single string:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f_op_string</span> <span class="o">=</span> <span class="n">FermionOperatorString</span><span class="p">(((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="n">f_op1</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">({</span><span class="n">f_op_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="n">f_op2</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">(</span><span class="n">f_op_string</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_op1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_op2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(1.0, F3^ F2 )
(1.0, F3^ F2 )
</pre></div>
</div>
</div>
</div>
<p>Additional construction methods are also available in the reference documentation for <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a>.  Standard algebraic manipulation is possible for this class:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f_op_string</span> <span class="o">=</span> <span class="n">FermionOperatorString</span><span class="p">(((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="n">f_op_string_conj</span> <span class="o">=</span> <span class="n">FermionOperatorString</span><span class="p">(((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="n">f_op</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">({</span><span class="n">f_op_string</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="n">f_op_conj</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">({</span><span class="n">f_op_string_conj</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="n">f_op_sum</span> <span class="o">=</span> <span class="n">f_op</span> <span class="o">+</span> <span class="n">f_op_conj</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_op_sum</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(1.0, F3^ F2 ), (1.0, F2^ F3 )
</pre></div>
</div>
</div>
</div>
<p>Various other methods for manipulating <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> instances are available in InQuanto. The
following example ( <a class="reference external" href="https://docs.quantinuum.com/inquanto/tutorials/examples_overview.html#operators">fermion_operator</a>) summarizes some of the
features of InQuanto’s <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> and <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> objects and their usage.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionOperator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionOperatorString</span>

<span class="c1"># construct a fermion operator</span>
<span class="n">op1</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">({</span><span class="n">FermionOperatorString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]):</span> <span class="mf">1.0</span><span class="p">})</span>

<span class="c1"># now multiply by its adjoint</span>
<span class="n">op</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op1</span><span class="o">.</span><span class="n">dagger</span><span class="p">()</span>

<span class="c1"># does it commute with itself? Yes!</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;commutator of op with itself:&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">commutator</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;does op commute with itself?&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">commutes_with</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>

<span class="c1"># instantiate from string</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">({</span><span class="n">FermionOperatorString</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;F1 F2^&quot;</span><span class="p">):</span> <span class="mf">3.5</span><span class="p">})</span>

<span class="c1"># is this normal ordered?</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is op2 normal ordered?&quot;</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">is_normal_ordered</span><span class="p">())</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">op2</span><span class="o">.</span><span class="n">normal_ordered</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;what about now?&quot;</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">is_normal_ordered</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is operator number conserving?&quot;</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">is_two_body_number_conserving</span><span class="p">())</span>

<span class="c1"># sum of operators so far:</span>
<span class="n">op3</span> <span class="o">=</span> <span class="n">op</span> <span class="o">+</span> <span class="n">op2</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;op3 =&quot;</span><span class="p">,</span> <span class="n">op3</span><span class="p">)</span>
<span class="c1"># remove terms with coefficients of absolute value &lt; 3</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;truncated op3 =&quot;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">truncated</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>

<span class="c1"># map this fermion operator to a qubit operator</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;JW mapped op3 =&quot;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">qubit_encode</span><span class="p">())</span>

<span class="c1"># we can apply the operators kets and bras defined in the fermion space to retrieve a new FermionState</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span>

<span class="n">fock_state</span> <span class="o">=</span> <span class="n">FermionState</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;HF|op3 = &quot;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">apply_bra</span><span class="p">(</span><span class="n">fock_state</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;op3|HF&gt; = &quot;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">apply_ket</span><span class="p">(</span><span class="n">fock_state</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>commutator of op with itself: (0.0, ), (0.0, F0^ F0 )
does op commute with itself? True
is op2 normal ordered? False
what about now? True
is operator number conserving? True
op3 = (1.0, F0  F0^), (-3.5, F2^ F1 )
truncated op3 = (-3.5, F2^ F1 )
JW mapped op3 = (0.5, ), (0.5, Z0), (-0.875j, Y1 X2), (-0.875, Y1 Y2), (-0.875, X1 X2), (0.875j, X1 Y2)
&lt;HF|op3 =  (0)
op3|HF&gt; =  (-3.5, {0: 1, 1: 0, 2: 1, 3: 0})
</pre></div>
</div>
</div>
</div>
<p>InQuanto also contains a class for dealing with sets of fermionic operators that are not linearly combined – the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorList" title="inquanto.operators.FermionOperatorList"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorList</span></code></a>.  Each separate <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a>
in the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorList" title="inquanto.operators.FermionOperatorList"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorList</span></code></a> may be associated with an additional scalar. This is particularly
useful when describing sequences of exponentiated fermionic operators, for example when considering variational ansatzes.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionOperatorList</span>
<span class="n">fol</span> <span class="o">=</span> <span class="n">FermionOperatorList</span><span class="p">([(</span><span class="n">sympify</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span><span class="n">op1</span><span class="p">),(</span><span class="n">sympify</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span><span class="n">op2</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fol</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>a         [(1.0, F0 )],
b         [(-3.5, F2^ F1 )]
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorList" title="inquanto.operators.FermionOperatorList"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorList</span></code></a> are designed to retain ordering for use in cases where operator ordering matters, such as exponentiation. In contrast, <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> is not naturally ordered.</p>
</div>
<p>This class is particularly useful for containing Trotter sequences.  The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> class contains various helper methods for generating such sequences.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">({</span><span class="n">FermionOperatorString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]):</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">({</span><span class="n">FermionOperatorString</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)]):</span> <span class="mf">1.0</span><span class="p">})</span>
<span class="n">op3</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span>
<span class="n">op_trotterized</span> <span class="o">=</span> <span class="n">op3</span><span class="o">.</span><span class="n">trotterize</span><span class="p">(</span><span class="n">trotter_number</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op_trotterized</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>0.5       [(1.0, F0  F1^)],
0.5       [(1.0, F2  F3^)],
0.5       [(1.0, F0  F1^)],
0.5       [(1.0, F2  F3^)]
</pre></div>
</div>
</div>
</div>
<p>Additional information on the functionality of these classes is provided in the API reference.</p>
</section>
</section>
<section id="qubit-spaces-operators-and-states">
<span id="qubit-spaces"></span><h2>Qubit spaces, operators and states<a class="headerlink" href="#qubit-spaces-operators-and-states" title="Permalink to this heading">¶</a></h2>
<p>For the analysis of many quantum algorithms, it is useful to work in a representation above the level of quantum circuits decomposed into some set of quantum gate primitives.  Similarly to the <a class="reference internal" href="#fermion-spaces"><span class="std std-ref">FermionSpace</span></a> class, qubit Hilbert spaces are represented in InQuanto using the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.QubitSpace" title="inquanto.spaces.QubitSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitSpace</span></code></a> class.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.spaces</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitSpace</span>
<span class="n">qubit_space</span> <span class="o">=</span> <span class="n">QubitSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>The <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.QubitSpace" title="inquanto.spaces.QubitSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitSpace</span></code></a> object represents the <span class="math notranslate nohighlight">\(2^N\)</span> dimensional Hilbert space of an <span class="math notranslate nohighlight">\(N\)</span>-qubit system.  For chemistry purposes, operators and states in a qubit Hilbert space are typically generated from fermionic operators and states, and thus the <a class="reference internal" href="../api/inquanto/spaces.html#inquanto.spaces.QubitSpace" title="inquanto.spaces.QubitSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitSpace</span></code></a> class does not have as many methods for directly generating operators and states as the fermionic equivalent.  However, methods for finding symmetry operators of a given qubit operator are included, as discussed in the <span class="xref std std-ref">symmetry</span> section.</p>
<section id="qubit-operators">
<h3>Qubit Operators<a class="headerlink" href="#qubit-operators" title="Permalink to this heading">¶</a></h3>
<p>Conventionally, operators acting upon states of qubits are typically represented as linear combinations of <em>Pauli strings</em></p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-6">
<div class="math notranslate nohighlight" id="equation-manual-spaces-6">
<span class="eqno">(73)<a class="headerlink" href="#equation-manual-spaces-6" title="Permalink to this equation">¶</a></span>\[\hat{O} = \sum_i{h_i} P_i\]</div>
</div>
<p>where each Pauli string</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-7">
<div class="math notranslate nohighlight" id="equation-manual-spaces-7">
<span class="eqno">(74)<a class="headerlink" href="#equation-manual-spaces-7" title="Permalink to this equation">¶</a></span>\[P_i = \bigotimes^N_{n=0}{p_n}\]</div>
</div>
<p>is a tensor product of single qubit Pauli <span class="math notranslate nohighlight">\(p_n \in \{I,X,Y,Z\}\)</span> operators and <span class="math notranslate nohighlight">\(N\)</span> is the number of qubits.  Any operator acting on a register of qubits can be decomposed in this form.  This representation is particularly useful when considering quantum chemistry problems, where operators acting on states of fermions must be mapped to operators acting on states of qubits prior to simulation.  In InQuanto, operators of this form are implemented using the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a> class.  In chemistry, instances of this will frequently derive from mapping a <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a>, however they may also be constructed manually.  Akin to the fermion operators discussed above, these comprise a map between <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperatorString" title="inquanto.operators.QubitOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperatorString</span></code></a> Pauli strings and numerical or symbolic coefficients.</p>
<p>Whereas <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorString" title="inquanto.operators.FermionOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorString</span></code></a> represents strings of creation and annihilation operators as a collection of pairs of integers (indexing modes) and <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span> (annihilation/creation), pytket provides us a more sophisticated approach to identifying qubits.  As such, a <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperatorString" title="inquanto.operators.QubitOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperatorString</span></code></a> contains a map between pytket <code class="xref py py-class docutils literal notranslate"><span class="pre">qubit</span></code> objects and <code class="xref py py-class docutils literal notranslate"><span class="pre">Pauli</span></code> objects, indicating which Pauli operator (of <span class="math notranslate nohighlight">\(\{I,X,Y,Z\}\)</span>) is acting on which qubit.  Note that this map is not necessarily exhaustive – while it may contain <em>explicit</em> identity operators, the operator is assumed to also <em>implicitly</em> act with the identity on any qubit not contained within the map.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitOperatorString</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket</span><span class="w"> </span><span class="kn">import</span> <span class="n">Qubit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.pauli</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pauli</span>

<span class="n">pauli_string</span> <span class="o">=</span> <span class="n">QubitOperatorString</span><span class="p">({</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pauli_string</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>{q[0]: &lt;Pauli.X: 1&gt;, q[1]: &lt;Pauli.X: 1&gt;}
</pre></div>
</div>
</div>
</div>
<p>Much like <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a>, a <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a> then stores a linear combination of Pauli strings as a map between these <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperatorString" title="inquanto.operators.QubitOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperatorString</span></code></a> objects and numerical or symbolic coefficients.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitOperator</span>
<span class="n">pauli_string</span> <span class="o">=</span> <span class="n">QubitOperatorString</span><span class="p">({</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">})</span>
<span class="n">op</span> <span class="o">=</span> <span class="n">QubitOperator</span><span class="p">({</span><span class="n">pauli_string</span><span class="p">:</span><span class="mf">1.0</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(1.0, X0 X1)
</pre></div>
</div>
</div>
</div>
<p>As with their fermionic counterparts, a variety of convenient alternative methods to construct the operator are provided, detailed in the API reference for <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a>.  Basic linear algebra is supported on these objects, along with various useful tools detailed in the API reference for <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">QubitOperator</span><span class="p">(</span><span class="s2">&quot;X0&quot;</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">QubitOperator</span><span class="p">(</span><span class="s2">&quot;Z0&quot;</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">op3</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Op1 + Op1:&#39;</span><span class="p">,</span> <span class="n">op3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Op1 conjugated:&#39;</span><span class="p">,</span> <span class="n">op1</span><span class="o">.</span><span class="n">dagger</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Commutator:&#39;</span><span class="p">,</span> <span class="n">op1</span><span class="o">.</span><span class="n">commutator</span><span class="p">(</span><span class="n">op2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sparse matrix form:&#39;</span><span class="p">,</span> <span class="n">op1</span><span class="o">.</span><span class="n">to_sparse_matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Identity:&#39;</span><span class="p">,</span> <span class="n">QubitOperator</span><span class="o">.</span><span class="n">identity</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Op1 + Op1: (1.0, X0), (1.0, Z0)
Op1 conjugated: (1.0, X0)
Commutator: (-2j, Y0)
Sparse matrix form: &lt;Compressed Sparse Column sparse matrix of dtype &#39;complex128&#39;
	with 2 stored elements and shape (2, 2)&gt;
  Coords	Values
  (1, 0)	(1+0j)
  (0, 1)	(1+0j)
Identity: (1.0, )
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These examples have used an alternative string construction method for the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a>, which is useful for simple examples such as this.</p>
</div>
<p>Several helper methods for determining properties of an operator are also available:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is operator Hermitian?&#39;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is operator anti-Hermitian?&#39;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">is_antihermitian</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is operator unitary?&#39;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">is_unitary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is operator unit-norm?&#39;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">is_unit_norm</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is operator self-inverse?&#39;</span><span class="p">,</span> <span class="n">op3</span><span class="o">.</span><span class="n">is_self_inverse</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Is operator Hermitian? True
Is operator anti-Hermitian? False
Is operator unitary? False
Is operator unit-norm? False
Is operator self-inverse? False
</pre></div>
</div>
</div>
</div>
<p>As mentioned above, a <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a>
consists of a mapping between <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperatorString" title="inquanto.operators.QubitOperatorString"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperatorString</span></code></a> objects and their
corresponding coefficients in the linear combination representing the operator. The terms may be extracted with the
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator.pauli_strings" title="inquanto.operators.QubitOperator.pauli_strings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pauli_strings()</span></code></a> property, whereas the coefficients may be extracted as a
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> with the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator.coefficients" title="inquanto.operators.QubitOperator.coefficients"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coefficients()</span></code></a> property.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Operator coefficients:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op3</span><span class="o">.</span><span class="n">coefficients</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pauli strings:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op3</span><span class="o">.</span><span class="n">pauli_strings</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Operator coefficients:
[1.0, 1.0]
Pauli strings:
[(Xq[0]), (Zq[0])]
</pre></div>
</div>
</div>
</div>
<p>Often when considering quantum algorithms, it is useful to describe qubit operators in their symplectic representation.
This consists of an <span class="math notranslate nohighlight">\((M\times 2N)\)</span> binary matrix where <span class="math notranslate nohighlight">\(M\)</span> is the number of independent Pauli strings in the
operator, and <span class="math notranslate nohighlight">\(N\)</span> is the number of qubits.  The leftmost half of this matrix designates whether a Pauli <span class="math notranslate nohighlight">\(X\)</span>
is acting on qubit <span class="math notranslate nohighlight">\(n\)</span> in term <span class="math notranslate nohighlight">\(m\)</span>, and the rightmost half designates whether a Pauli <span class="math notranslate nohighlight">\(Z\)</span> is acting on
the same qubit in the same term.  As <span class="math notranslate nohighlight">\(Y = \mathrm{i} XZ\)</span>, both leftmost and rightmost entries are <span class="math notranslate nohighlight">\(1\)</span> if a
Pauli <span class="math notranslate nohighlight">\(Y\)</span> is present.  Note that in this representation, information regarding the coefficients of each term must
be stored independently.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">symplectic_representation</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[ True False]]
</pre></div>
</div>
</div>
</div>
<p>InQuanto additionally provides a class for dealing with sets of Pauli operators that are not linearly combined, akin to the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperatorList" title="inquanto.operators.FermionOperatorList"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperatorList</span></code></a> – the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperatorList" title="inquanto.operators.QubitOperatorList"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperatorList</span></code></a>.  This provides similar functionality to that of its fermionic counterpart.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitOperatorList</span>
<span class="n">qol</span> <span class="o">=</span> <span class="n">QubitOperatorList</span><span class="p">([(</span><span class="n">sympify</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span><span class="n">op1</span><span class="p">),(</span><span class="n">sympify</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span><span class="n">op2</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qol</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>a         [(1.0, X0)],
b         [(1.0, Z0)]
</pre></div>
</div>
</div>
</div>
<p>Trotterization functionality is also available for the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">QubitOperator</span><span class="p">(</span><span class="s2">&quot;X0&quot;</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">QubitOperator</span><span class="p">(</span><span class="s2">&quot;Z0&quot;</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">op3</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span>
<span class="n">op_trotterized</span> <span class="o">=</span> <span class="n">op3</span><span class="o">.</span><span class="n">trotterize</span><span class="p">(</span><span class="n">trotter_number</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">op_trotterized</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>0.5       [(1.0, X0)],
0.5       [(1.0, Z0)],
0.5       [(1.0, X0)],
0.5       [(1.0, Z0)]
</pre></div>
</div>
</div>
</div>
<p>The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">API</span> <span class="pre">reference</span></code></a> details these methods, and provides a full breakdown of the other functionality available for the <code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperatorList</span></code> classes.</p>
</section>
<section id="qubit-states-expectation-values">
<h3>Qubit States &amp; Expectation Values<a class="headerlink" href="#qubit-states-expectation-values" title="Permalink to this heading">¶</a></h3>
<p>A register of <span class="math notranslate nohighlight">\(N\)</span> qubits corresponds to a <span class="math notranslate nohighlight">\(\mathcal{C}^{2^{N}}\)</span> Hilbert space.  As such, it can be represented with a <span class="math notranslate nohighlight">\(2^N\)</span> dimensional vector of complex numbers.  Clearly, generating such a vector is not scalable on a classical computer (otherwise we wouldn’t need quantum computers), but this approach can be practical for small <span class="math notranslate nohighlight">\(N\)</span>.  For some tasks (for instance, if we are simulating the action of a known Clifford operator), we can guarantee that a given state will have polynomial support.  In this case, we can efficiently store the state in a sparse state vector.  InQuanto provides an alternative to an explicit sparse state vector representation of states in the form of the <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.QubitState" title="inquanto.states.QubitState"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitState</span></code></a> class, instances of which consist of linear combinations of <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.QubitStateString" title="inquanto.states.QubitStateString"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitStateString</span></code></a> objects.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitState</span>
<span class="n">qubit_state</span> <span class="o">=</span> <span class="n">QubitState</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">1.</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qubit_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(1.0, {q[0]: 1, q[1]: 1, q[2]: 0, q[3]: 0})
</pre></div>
</div>
</div>
</div>
<p>These can be converted to state vector representations:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">state_vector</span> <span class="o">=</span> <span class="n">qubit_state</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state_vector</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]
 [1.+0.j]
 [0.+0.j]
 [0.+0.j]
 [0.+0.j]]
</pre></div>
</div>
</div>
</div>
<p>Most importantly for the purposes of analyzing quantum algorithms, the <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.QubitState" title="inquanto.states.QubitState"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitState</span></code></a> representation allows for performing linear algebra with other <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.QubitState" title="inquanto.states.QubitState"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitState</span></code></a> and <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a> objects.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">overlap</span> <span class="o">=</span> <span class="n">qubit_state</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">qubit_state</span><span class="p">)</span>
<span class="n">expectation_value</span> <span class="o">=</span> <span class="n">op1</span><span class="o">.</span><span class="n">state_expectation</span><span class="p">(</span><span class="n">qubit_state</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Overlap:&#39;</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Expectation value:&#39;</span><span class="p">,</span> <span class="n">expectation_value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Overlap: 1.0
Expectation value: 0
</pre></div>
</div>
</div>
</div>
<p><a class="reference internal" href="../api/inquanto/states.html#inquanto.states.QubitState" title="inquanto.states.QubitState"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitState</span></code></a> objects are implicitly sparse, in contrast to full dense statevector representations.  Performing calculations in this way allows for the analysis of qubit states and operators without the need to either generate full circuit representations, or the expensive generation of full <span class="math notranslate nohighlight">\(2^{2N}\)</span> matrix representations of operators.</p>
</section>
</section>
<section id="fermion-to-qubit-mapping">
<span id="qubit-mapping"></span><h2>Fermion-to-Qubit Mapping<a class="headerlink" href="#fermion-to-qubit-mapping" title="Permalink to this heading">¶</a></h2>
<p>In quantum chemistry, we are most often concerned with the properties of electrons.  As electrons are fermions, second-quantized fermionic creation and annihilation operators obey the fermionic anticommutation relations:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-8">
<div class="math notranslate nohighlight" id="equation-manual-spaces-8">
<span class="eqno">(75)<a class="headerlink" href="#equation-manual-spaces-8" title="Permalink to this equation">¶</a></span>\[\{\hat{a}^\dagger_i , \hat{a}^\dagger_j\} = 0, \{\hat{a}_i , \hat{a}_j\} = 0, \{\hat{a}^\dagger_i , \hat{a}_j\} = \delta_{i,j}\]</div>
</div>
<p>This implicitly restricts the occupation number of a given fermionic mode to <span class="math notranslate nohighlight">\(\{0,1\}\)</span>.  Conversely, qubits can be considered to be <em>paraparticles</em>.  Like fermionic modes, each qubit is a two-level system.  However, the above fermionic anticommutation relations are not obeyed:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-9">
<div class="math notranslate nohighlight" id="equation-manual-spaces-9">
<span class="eqno">(76)<a class="headerlink" href="#equation-manual-spaces-9" title="Permalink to this equation">¶</a></span>\[\begin{split}\mathinner{|{1}\rangle} \mathinner{\langle{0}|}_i = X_i - \mathrm{i}Y_i, \\ \mathinner{|{0}\rangle} \mathinner{\langle{1}|}_i = X_i + \mathrm{i}Y_i
\\ \{X_i - \mathrm{i}Y_i , X_j + \mathrm{i}Y_j\} \neq \delta_{i,j}\end{split}\]</div>
</div>
<p>As such, in order to use a system of qubits to simulate a system of fermions, the fermionic anticommutation relations must be encoded.  An encoding scheme consists of a linear map between states and operators in the fermionic Hilbert space and the states and operators in the qubit Hilbert space.  For quantum chemistry purposes, mapping both states and operators is important - for example, in a canonical VQE calculation, both the Hamiltonian operator and the reference state must be mapped to the qubit space.</p>
<p>In InQuanto, fermion-to-qubit mappings are stored in the <a class="reference internal" href="../api/inquanto/mappings.html#mappings-api"><span class="std std-ref">inquanto.mappings</span></a> module.  Four mappings are included in the current version:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMappingJordanWigner" title="inquanto.mappings.QubitMappingJordanWigner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Jordan-Wigner</span> <span class="pre">transformation</span></code></a></p></li>
<li><p><a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMappingBravyiKitaev" title="inquanto.mappings.QubitMappingBravyiKitaev"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bravyi-Kitaev</span> <span class="pre">mapping</span></code></a></p></li>
<li><p><a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMappingParity" title="inquanto.mappings.QubitMappingParity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parity</span> <span class="pre">mapping</span></code></a></p></li>
<li><p><a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMappingParaparticular" title="inquanto.mappings.QubitMappingParaparticular"><code class="xref py py-class docutils literal notranslate"><span class="pre">&quot;Paraparticular&quot;</span> <span class="pre">mapping</span></code></a> – this does not encode fermionic statistics</p></li>
</ul>
<p>In order to map an InQuanto <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> to a <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.QubitOperator" title="inquanto.operators.QubitOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitOperator</span></code></a>, the <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.operator_map" title="inquanto.mappings.QubitMapping.operator_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">operator_map()</span></code></a> method can be used:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionOperator</span><span class="p">,</span><span class="n">FermionOperatorString</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.mappings</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitMappingJordanWigner</span>
<span class="n">fermion_operator</span> <span class="o">=</span> <span class="n">FermionOperator</span><span class="p">(</span><span class="n">FermionOperatorString</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]),</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">qubit_operator</span> <span class="o">=</span> <span class="n">QubitMappingJordanWigner</span><span class="o">.</span><span class="n">operator_map</span><span class="p">(</span><span class="n">fermion_operator</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qubit_operator</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(0.25, Z0 X1), (0.25j, Z0 Y1)
</pre></div>
</div>
</div>
</div>
<p>and similarly, to map <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.FermionState" title="inquanto.states.FermionState"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionState</span></code></a> objects to <a class="reference internal" href="../api/inquanto/states.html#inquanto.states.QubitState" title="inquanto.states.QubitState"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitState</span></code></a> objects, the <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.state_map" title="inquanto.mappings.QubitMapping.state_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state_map()</span></code></a> method is used:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span>
<span class="n">fermion_state</span> <span class="o">=</span> <span class="n">FermionState</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qubit_state</span> <span class="o">=</span> <span class="n">QubitMappingJordanWigner</span><span class="o">.</span><span class="n">state_map</span><span class="p">(</span><span class="n">fermion_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>Note that both of these methods include an optional argument specifying the register of tket <code class="xref py py-class docutils literal notranslate"><span class="pre">Qubit</span></code> objects that comprise the target qubit space.  Without this argument provided (as above), the mapping will if possible infer that a minimally sized register is to be used, indexed incrementally from 0.  For some mappings (for example, the Bravyi-Kitaev mapping), this information cannot be inferred.  If these mappings are used, it is necessary to specify the qubit register.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket</span><span class="w"> </span><span class="kn">import</span> <span class="n">Qubit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.mappings</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitMappingBravyiKitaev</span>
<span class="n">qubit_operator_bk</span> <span class="o">=</span> <span class="n">QubitMappingBravyiKitaev</span><span class="o">.</span><span class="n">operator_map</span><span class="p">(</span><span class="n">fermion_operator</span><span class="p">,[</span><span class="n">Qubit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qubit_operator_bk</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(0.25, Z0 X1 X3 X7), (0.25j, Y1 X3 X7)
</pre></div>
</div>
</div>
</div>
<p>Finally, when performing state vector simulations one may wish to represent fermionic and qubit states in the form of full dense or sparse vectors of complex numbers.  The <a class="reference internal" href="../api/inquanto/mappings.html#mappings-api"><span class="std std-ref">inquanto.mappings</span></a> classes support this, and will return in the same representation as the input.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">csc_matrix</span>
<span class="n">dense_fermionic_state</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">sparse_fermionic_state</span> <span class="o">=</span> <span class="n">csc_matrix</span><span class="p">(</span><span class="n">dense_fermionic_state</span><span class="p">)</span>
<span class="n">dense_qubit_state</span> <span class="o">=</span> <span class="n">QubitMappingJordanWigner</span><span class="o">.</span><span class="n">state_map</span><span class="p">(</span><span class="n">dense_fermionic_state</span><span class="p">,</span><span class="n">qubits</span><span class="o">=</span><span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="n">sparse_qubit_state</span> <span class="o">=</span> <span class="n">QubitMappingJordanWigner</span><span class="o">.</span><span class="n">state_map</span><span class="p">(</span><span class="n">sparse_fermionic_state</span><span class="p">,</span><span class="n">qubits</span><span class="o">=</span><span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dense_qubit_state</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sparse_qubit_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[1]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]]
&lt;Compressed Sparse Column sparse matrix of dtype &#39;int64&#39;
	with 1 stored elements and shape (16, 1)&gt;
  Coords	Values
  (0, 0)	1
</pre></div>
</div>
</div>
</div>
<section id="custom-mappings">
<h3>Custom mappings<a class="headerlink" href="#custom-mappings" title="Permalink to this heading">¶</a></h3>
<p>For advanced usage, it is possible to define custom mapping schemes.  The <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping" title="inquanto.mappings.QubitMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitMapping</span></code></a> class is a superclass containing the logic of the <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.operator_map" title="inquanto.mappings.QubitMapping.operator_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">operator_map()</span></code></a>  and <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.state_map" title="inquanto.mappings.QubitMapping.state_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state_map()</span></code></a> methods.  Custom mappings can be designed by subclassing this and implementing the <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.update_set" title="inquanto.mappings.QubitMapping.update_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_set()</span></code></a> , <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.parity_set" title="inquanto.mappings.QubitMapping.parity_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parity_set()</span></code></a> , <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.rho_set" title="inquanto.mappings.QubitMapping.rho_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rho_set()</span></code></a> and <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.state_map_matrix" title="inquanto.mappings.QubitMapping.state_map_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state_map_matrix()</span></code></a>  methods.  The first three of these methods return sets of qubits according to the formalism of Seeley, Richard and Love <span id="id4">[<a class="reference internal" href="../misc/bibliography.html#id21" title="Jacob T. Seeley, Martin J. Richard, and Peter J. Love. The Bravyi-Kitaev transformation for quantum computation of electronic structure. The Journal of Chemical Physics, 137(22):224109, December 2012. doi:10.1063/1.4768229.">38</a>]</span>.  The <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.state_map_matrix" title="inquanto.mappings.QubitMapping.state_map_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state_map_matrix()</span></code></a> method returns a matrix which transforms a binary column vector representation of the binary index corresponding to a given basis state in the fermionic space, to a similar vector in the qubit space.  In the flip/update/parity/rho set formalism, fermionic creation and annihilation operators are mapped according to the following relation:</p>
<div class="math-wrapper docutils container" id="equation-eqn-mappings">
<div class="math notranslate nohighlight" id="equation-eqn-mappings">
<span class="eqno">(77)<a class="headerlink" href="#equation-eqn-mappings" title="Permalink to this equation">¶</a></span>\[ \begin{align}\begin{aligned}&amp;a^\dagger_i \rightarrow \frac{1}{2} (X_{U(i)} X_i Z_{P(i)} - \mathrm{i}X_{U(i)} Y_i Z_{\rho(i)})\\&amp;a_i \rightarrow \frac{1}{2} (X_{U(i)} X_i Z_{P(i)} + \mathrm{i}X_{U(i)} Y_i Z_{\rho(i)})\end{aligned}\end{align} \]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(U(i)\)</span> is the update set, <span class="math notranslate nohighlight">\(P(i)\)</span> is the parity set, <span class="math notranslate nohighlight">\(\rho(i)\)</span> is the rho set for orbital <span class="math notranslate nohighlight">\(i\)</span>.  As an example, for the Jordan-Wigner mapping:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-10">
<div class="math notranslate nohighlight" id="equation-manual-spaces-10">
<span class="eqno">(78)<a class="headerlink" href="#equation-manual-spaces-10" title="Permalink to this equation">¶</a></span>\[ \begin{align}\begin{aligned}&amp;a^\dagger_i \rightarrow \frac{1}{2} \left(X_i - \mathrm{i} Y_i \right) \otimes Z^{\otimes i}\\&amp;a_i \rightarrow \frac{1}{2} \left(X_i + \mathrm{i} Y_i \right) \otimes Z^{\otimes i}\end{aligned}\end{align} \]</div>
</div>
<p>Comparing this against <a class="reference internal" href="#equation-eqn-mappings">(77)</a> we see the update and flip set are always empty, whereas the parity set consists of all qubits with index less than <span class="math notranslate nohighlight">\(i\)</span>.  <a class="reference internal" href="../api/inquanto/mappings.html#inquanto.mappings.QubitMapping.state_map_matrix" title="inquanto.mappings.QubitMapping.state_map_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state_map_matrix()</span></code></a> for the Jordan-Wigner transformation will always return the identity matrix, since state <span class="math notranslate nohighlight">\(\ket{n}\)</span> in the fermionic space is always mapped to state <span class="math notranslate nohighlight">\(\ket{n}\)</span> in the qubit space.</p>
</section>
</section>
<section id="integral-operators">
<span id="id5"></span><h2>Integral Operators<a class="headerlink" href="#integral-operators" title="Permalink to this heading">¶</a></h2>
<p>We have described <a class="reference internal" href="#fermion-spaces"><span class="std std-ref">above</span></a> how InQuanto stores and handles the fermionic Hamiltonian via the
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> class.  The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> class stores
those operators and numeric integral values as items of a dictionary. Such storage is convenient for manipulating
and accessing individual terms of the Hamiltonian, but is not tailored well to linear algebra operations, such as
integral transformation.</p>
<p>The InQuanto <a class="reference internal" href="../api/inquanto/operators.html#module-inquanto.operators" title="inquanto.operators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">operators</span></code></a> module provides integral operator classes for storing and manipulating
chemistry integrals (<span class="math notranslate nohighlight">\(h_{ij}\)</span> and <span class="math notranslate nohighlight">\(h_{ijkl}\)</span>, typically molecular orbital integrals) as algebraic objects.
The standard integral operators are the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator" title="inquanto.operators.ChemistryRestrictedIntegralOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemistryRestrictedIntegralOperator</span></code></a> and
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryUnrestrictedIntegralOperator" title="inquanto.operators.ChemistryUnrestrictedIntegralOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemistryUnrestrictedIntegralOperator</span></code></a>
classes, for spin-restricted and spin-unrestricted formalisms respectively. In the restricted case, one-body
integrals are stored in a 2-dimensional <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> array with shape <code class="code docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code>, and two-body integrals
in a 4-dimensional array with shape <code class="code docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n,</span> <span class="pre">n,</span> <span class="pre">n)</span></code>, where <code class="code docutils literal notranslate"><span class="pre">n</span></code> is the number of spatial orbitals.
In the unrestricted case, the <span class="math notranslate nohighlight">\(\uparrow\)</span> and <span class="math notranslate nohighlight">\(\downarrow\)</span> spin channels have
independent integrals. Hence, two 2-dimensional arrays store the one-body integrals, one for each spin channel, and
four 4-dimensional arrays store all spin-configurations of the two-body integrals
(<span class="math notranslate nohighlight">\(\upuparrows\upuparrows, \downdownarrows\downdownarrows, \upuparrows\downdownarrows\)</span> and <span class="math notranslate nohighlight">\(\downdownarrows\upuparrows\)</span>).</p>
<p>The <span class="xref std std-ref">inquanto-pyscf</span> extension is the primary tool for generating integral operators for a chemical system,
though integral operators may also be instantiated directly with <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> arrays (see the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator" title="inquanto.operators.ChemistryRestrictedIntegralOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemistryRestrictedIntegralOperator</span></code></a>
and <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryUnrestrictedIntegralOperator" title="inquanto.operators.ChemistryUnrestrictedIntegralOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemistryUnrestrictedIntegralOperator</span></code></a> constructors). Below, we use the <a class="reference internal" href="express.html#express"><span class="std std-ref">Express</span></a> module
to load in a pre-computed integral operator for LiH:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.express</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_h5</span>

<span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">max_rows</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">lih_sto3g</span> <span class="o">=</span> <span class="n">load_h5</span><span class="p">(</span><span class="s1">&#39;lih_sto3g.h5&#39;</span><span class="p">,</span> <span class="n">as_tuple</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">integral_operator</span> <span class="o">=</span> <span class="n">lih_sto3g</span><span class="o">.</span><span class="n">hamiltonian_operator</span>
<span class="nb">print</span><span class="p">(</span><span class="n">integral_operator</span><span class="o">.</span><span class="n">df</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>      Coefficient                 Term
0        1.050650                     
1       -4.746695              F0^ F0 
2        0.109103              F0^ F2 
3        0.168024              F0^ F4 
4       -0.026783             F0^ F10 
...           ...                  ...
1496     0.009754    F11^ F10^ F8  F9 
1497     0.009754    F11^ F10^ F8  F9 
1498     0.228088  F11^ F10^ F10  F11 
1499     0.228088  F11^ F10^ F10  F11 
1500    -0.935480            F11^ F11 

[1501 rows x 2 columns]
</pre></div>
</div>
</div>
</div>
<p>where the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.df" title="inquanto.operators.ChemistryRestrictedIntegralOperator.df"><code class="xref py py-meth docutils literal notranslate"><span class="pre">df()</span></code></a> method produces a <code class="xref py py-mod docutils literal notranslate"><span class="pre">pandas</span></code> dataframe
of all integrals and their corresponding fermion operator terms. Integral operators may be converted directly into a qubit Hamiltonian with the
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.qubit_encode" title="inquanto.operators.ChemistryRestrictedIntegralOperator.qubit_encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">qubit_encode()</span></code></a> method, which uses Jordan-Wigner mapping by default:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_hamiltonian</span> <span class="o">=</span> <span class="n">integral_operator</span><span class="o">.</span><span class="n">qubit_encode</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LiH STO-3G JW qubit hamiltonian:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">df</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>LiH STO-3G JW qubit hamiltonian:
      Coefficient                                   Term  \
0      -4.107196                                          
1      -0.396888                                    Z11   
2      -0.396888                                    Z10   
3       0.114044                                Z10 Z11   
4      -0.228984                                     Z9   
..           ...                                    ...   
626    -0.011161  Z0 X1 Z2 Z3 Z4 Z5 Z6 Z7 Z8 Z9 Z10 X11   
627     0.029058                            Z0 Y1 Z2 Y3   
628     0.034437                      Z0 Y1 Z2 Z3 Z4 Y5   
629    -0.011161  Z0 Y1 Z2 Z3 Z4 Z5 Z6 Z7 Z8 Z9 Z10 Y11   
630     0.414556                                  Z0 Z1   

            Coefficient type  
0    &lt;class &#39;numpy.float64&#39;&gt;  
1    &lt;class &#39;numpy.float64&#39;&gt;  
2    &lt;class &#39;numpy.float64&#39;&gt;  
3    &lt;class &#39;numpy.float64&#39;&gt;  
4    &lt;class &#39;numpy.float64&#39;&gt;  
..                       ...  
626  &lt;class &#39;numpy.float64&#39;&gt;  
627  &lt;class &#39;numpy.float64&#39;&gt;  
628  &lt;class &#39;numpy.float64&#39;&gt;  
629  &lt;class &#39;numpy.float64&#39;&gt;  
630  &lt;class &#39;numpy.float64&#39;&gt;  

[631 rows x 3 columns]
</pre></div>
</div>
</div>
</div>
<p>Unitary transformations may be applied to the integrals with the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.rotate" title="inquanto.operators.ChemistryRestrictedIntegralOperator.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a> method,
which takes a unitary matrix and transforms in-place:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">ortho_group</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">ortho_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">lih_sto3g</span><span class="o">.</span><span class="n">n_orbital</span><span class="p">)</span>  <span class="c1"># Random, real unitary matrix</span>
<span class="n">integral_operator</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">integral_operator</span><span class="o">.</span><span class="n">df</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>      Coefficient                 Term
0        1.050650                     
1       -2.067698              F0^ F0 
2        0.114759              F0^ F2 
3        0.410204              F0^ F4 
4       -0.643457              F0^ F6 
...           ...                  ...
4460    -0.070572   F11^ F10^ F9  F10 
4461    -0.070572   F11^ F10^ F9  F10 
4462     0.253911  F11^ F10^ F10  F11 
4463     0.253911  F11^ F10^ F10  F11 
4464    -2.131845            F11^ F11 

[4465 rows x 2 columns]
</pre></div>
</div>
</div>
</div>
<p>Integral operators support other utility methods including <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.approx_equal" title="inquanto.operators.ChemistryRestrictedIntegralOperator.approx_equal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">approx_equal()</span></code></a>,
for comparing Hamiltonians, <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.items" title="inquanto.operators.ChemistryRestrictedIntegralOperator.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code></a>, which iterates over terms, and
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.to_FermionOperator" title="inquanto.operators.ChemistryRestrictedIntegralOperator.to_FermionOperator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_FermionOperator()</span></code></a>, for converting between operator and integral focused objects.</p>
<p>Alongside integral operators, the <a class="reference internal" href="../api/inquanto/operators.html#module-inquanto.operators" title="inquanto.operators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">operators</span></code></a> module also provides a set of classes for managing reduced density matrices (RDMs).
These may be used in combination with integral operators to compute useful properties of the Hamiltonian. For example, with the
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.UnrestrictedOneBodyRDM" title="inquanto.operators.UnrestrictedOneBodyRDM"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnrestrictedOneBodyRDM</span></code></a> we may compute the total mean-field energy and effective potential matrices:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnrestrictedOneBodyRDM</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">integral_operator</span> <span class="o">=</span> <span class="n">load_h5</span><span class="p">(</span><span class="s1">&#39;h3_sto3g_m2_u.h5&#39;</span><span class="p">,</span> <span class="n">as_tuple</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">hamiltonian_operator</span>
<span class="n">rdm1</span> <span class="o">=</span> <span class="n">UnrestrictedOneBodyRDM</span><span class="p">(</span><span class="n">rdm1_aa</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">rdm1_bb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean-field energy:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">integral_operator</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="n">rdm1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Effective potential a:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">integral_operator</span><span class="o">.</span><span class="n">effective_potential</span><span class="p">(</span><span class="n">rdm1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Effective potential b:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">integral_operator</span><span class="o">.</span><span class="n">effective_potential</span><span class="p">(</span><span class="n">rdm1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Mean-field energy:
 -1.5140974066187696

Effective potential a:
 [[ 0.996 -0.     0.226]
 [-0.     0.924  0.   ]
 [ 0.226  0.     1.632]]

Effective potential b:
 [[ 1.163 -0.     0.069]
 [-0.     1.541  0.   ]
 [ 0.069 -0.     1.712]]
</pre></div>
</div>
</div>
</div>
<p>Above, RDM is initialized with <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> arrays in the same basis as the integral operator. The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.energy" title="inquanto.operators.ChemistryRestrictedIntegralOperator.energy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">energy()</span></code></a>
method may also be provided with a 2-RDM (see <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.RestrictedTwoBodyRDM" title="inquanto.operators.RestrictedTwoBodyRDM"><code class="xref py py-class docutils literal notranslate"><span class="pre">RestrictedTwoBodyRDM</span></code></a> and <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.UnrestrictedTwoBodyRDM" title="inquanto.operators.UnrestrictedTwoBodyRDM"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnrestrictedTwoBodyRDM</span></code></a>)
to calculate the total, non-mean-field, energy.</p>
<p>In addition to the basic integral operator classes, InQuanto also includes compact integral operators:
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperatorCompact" title="inquanto.operators.ChemistryRestrictedIntegralOperatorCompact"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemistryRestrictedIntegralOperatorCompact</span></code></a> and <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryUnrestrictedIntegralOperatorCompact" title="inquanto.operators.ChemistryUnrestrictedIntegralOperatorCompact"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemistryUnrestrictedIntegralOperatorCompact</span></code></a>,
which exploit symmetries in the two-body integrals to reduce classical memory requirements. Compact integral operator classes support the same operations
as discussed above, and are most naturally instantiated using the <span class="xref std std-ref">inquanto-pyscf</span> extension.</p>
<section id="interfacing-with-quantum-chemistry-packages-via-fcidump">
<span id="interfacing-quantum-chemistry"></span><h3>Interfacing with Quantum Chemistry Packages via FCIDUMP<a class="headerlink" href="#interfacing-with-quantum-chemistry-packages-via-fcidump" title="Permalink to this heading">¶</a></h3>
<p>InQuanto also supports interfacing with integrals from other quantum chemistry packages via the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FCIDumpRestricted" title="inquanto.operators.FCIDumpRestricted"><code class="xref py py-class docutils literal notranslate"><span class="pre">FCIDumpRestricted</span></code></a>
and <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FCIDumpUnrestricted" title="inquanto.operators.FCIDumpUnrestricted"><code class="xref py py-class docutils literal notranslate"><span class="pre">FCIDumpUnrestricted</span></code></a> classes,
so long as the package supports the generation of output files in the FCIDUMP format:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FCIDumpRestricted</span>

<span class="n">fdr</span> <span class="o">=</span> <span class="n">FCIDumpRestricted</span><span class="p">()</span>
<span class="n">fdr</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;fcidump&quot;</span><span class="p">)</span>

<span class="n">integral_operator</span> <span class="o">=</span> <span class="n">fdr</span><span class="o">.</span><span class="n">to_ChemistryRestrictedIntegralOperator</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">&quot;fcidump&quot;</span></code> is the file containing the FCIDUMP output file.
For details on generating these files, one should refer to the documentation of the desired quantum chemistry package.
For example, using the Psi4 package:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">psi4</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FCIDumpRestricted</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;2</span><span class="se">\n\n</span><span class="s2">H 0 0 0</span><span class="se">\n</span><span class="s2">H 0 0 1&quot;</span><span class="p">)</span>
<span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">(</span>
    <span class="nb">dict</span><span class="p">(</span>
        <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;cc-pvdz&quot;</span><span class="p">,</span>
        <span class="n">reference</span><span class="o">=</span><span class="s2">&quot;rhf&quot;</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="n">energy</span><span class="p">,</span> <span class="n">wfn</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s2">&quot;scf&quot;</span><span class="p">,</span> <span class="n">return_wfn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">psi4</span><span class="o">.</span><span class="n">fcidump</span><span class="p">(</span><span class="n">wfn</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s2">&quot;fcidump&quot;</span><span class="p">)</span>

<span class="n">fdr</span> <span class="o">=</span> <span class="n">FCIDumpRestricted</span><span class="p">()</span>
<span class="n">fdr</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;fcidump&quot;</span><span class="p">)</span>

<span class="n">integral_operator</span> <span class="o">=</span> <span class="n">fdr</span><span class="o">.</span><span class="n">to_ChemistryRestrictedIntegralOperator</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">integral_operator</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">integral_operator</span><span class="o">.</span><span class="n">_get_constant</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;inquanto.operators._chemistry_integral_operator.ChemistryRestrictedIntegralOperator&#39;&gt;
0.5291772106699999
0.5291772106699999
</pre></div>
</div>
</div>
</div>
</section>
<section id="unrestricted-integrals">
<span id="unrestricted-interfacing-quantum-chemistry"></span><h3>Unrestricted integrals<a class="headerlink" href="#unrestricted-integrals" title="Permalink to this heading">¶</a></h3>
<p>When working with unrestricted integrals, the encoding format of the spatial and spin index must be considered.
The <code class="docutils literal notranslate"><span class="pre">spin_index_format</span></code> keyword argument controls this detail, supporting the following options:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;block&quot;</span></code>: Integrals are ordered by spatial index, with blocks delimited by a <cite>0.0 0 0 0 0</cite> line.
The order of the spin blocks is <cite>(aa|aa)</cite>, <cite>(bb|bb)</cite>, <cite>(aa|bb)</cite>, <cite>(a|h|a)</cite>, <cite>(b|h|b)</cite>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;minor&quot;</span></code>: Integrals are ordered by spin index, with alternating alpha and beta spin orbitals corresponding
to each spatial orbital.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;major&quot;</span></code>: Integrals are ordered by spin index, with all alpha spin orbitals corresponding to each spatial
orbital, followed by all spin orbitals corresponding to each spatial orbital.</p></li>
</ul>
</div></blockquote>
<p>The choice of this parameter depends on the construction of the file for the particular code package.
For example, once again using the Psi4 package:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">psi4</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">FCIDumpUnrestricted</span>

<span class="n">psi4</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="s2">&quot;2</span><span class="se">\n\n</span><span class="s2">H 0 0 0</span><span class="se">\n</span><span class="s2">H 0 0 1&quot;</span><span class="p">)</span>
<span class="n">psi4</span><span class="o">.</span><span class="n">set_options</span><span class="p">(</span>
    <span class="nb">dict</span><span class="p">(</span>
        <span class="n">basis</span><span class="o">=</span><span class="s2">&quot;cc-pvdz&quot;</span><span class="p">,</span>
        <span class="n">reference</span><span class="o">=</span><span class="s2">&quot;uhf&quot;</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="n">energy</span><span class="p">,</span> <span class="n">wfn</span> <span class="o">=</span> <span class="n">psi4</span><span class="o">.</span><span class="n">energy</span><span class="p">(</span><span class="s2">&quot;scf&quot;</span><span class="p">,</span> <span class="n">return_wfn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">psi4</span><span class="o">.</span><span class="n">fcidump</span><span class="p">(</span><span class="n">wfn</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="s2">&quot;fcidump&quot;</span><span class="p">)</span>

<span class="n">fdr</span> <span class="o">=</span> <span class="n">FCIDumpUnrestricted</span><span class="p">(</span><span class="n">spin_index_format</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">)</span>
<span class="n">fdr</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;fcidump&quot;</span><span class="p">)</span>

<span class="n">integral_operator</span> <span class="o">=</span> <span class="n">fdr</span><span class="o">.</span><span class="n">to_ChemistryUnrestrictedIntegralOperator</span><span class="p">()</span>
</pre></div>
</div>
<p>InQuanto tests the creation of chemistry integral objects from FCIDUMP files generated using PySCF, Psi4, and NWChem.
Care should be taken when importing integrals from other codes as syntax can vary.</p>
</section>
</section>
<section id="orbital-transformation-and-optimization">
<span id="orbital-transformation"></span><h2>Orbital Transformation and Optimization<a class="headerlink" href="#orbital-transformation-and-optimization" title="Permalink to this heading">¶</a></h2>
<p>Slater determinants, represented by vectors in Fock space, are functions of molecular orbitals. Typically the molecular
orbitals are found by solving some other problem, such as the Hartree-Fock equations, but in some cases orbitals are
chosen to be some other set of functions. For instance, they could be localized or optimized in some other way. InQuanto
contains tools to help with procedures of this type, and to facilitate the transfer of these methods to quantum
algorithms.</p>
<p>The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.OrbitalTransformer" title="inquanto.operators.OrbitalTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrbitalTransformer</span></code></a> class contains several methods for common practices in molecular orbital manipulation. For
instance, to Gram-Schmidt orthogonalize a set of molecular orbitals in an orthogonal atomic orbital basis,</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrbitalTransformer</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="n">orbitals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">ot</span> <span class="o">=</span> <span class="n">OrbitalTransformer</span><span class="p">()</span>
<span class="n">ot</span><span class="o">.</span><span class="n">gram_schmidt</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([[-0.316, -0.949],
       [-0.949,  0.316]])
</pre></div>
</div>
</div>
</div>
<p>or, equivalently, in a non-orthogonal atomic orbital basis,</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.66314574</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.66314574</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
<span class="n">ot</span><span class="o">.</span><span class="n">gram_schmidt</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([[-0.267, -1.309],
       [-0.802,  1.068]])
</pre></div>
</div>
</div>
</div>
<p>One can achieve the same goal of orthonormalization using the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.OrbitalTransformer.orthonormalize" title="inquanto.operators.OrbitalTransformer.orthonormalize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">orthonormalize()</span></code></a>
method, which finds the closest orthonormal set by the symmetric transformation.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ot</span><span class="o">.</span><span class="n">orthonormalize</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([[-0.887,  0.999],
       [ 1.336,  0.001]])
</pre></div>
</div>
</div>
</div>
<p>The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.OrbitalTransformer" title="inquanto.operators.OrbitalTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrbitalTransformer</span></code></a> object also defines a method for computing the unitary which relates two sets of molecular
orbitals. For example, to find the unitary relating the MO coefficients in the matrix <span class="math notranslate nohighlight">\(X\)</span> with those in matrix <span class="math notranslate nohighlight">\(C\)</span>,</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="n">ot</span> <span class="o">=</span> <span class="n">OrbitalTransformer</span><span class="p">()</span>
<span class="n">my_unitary</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">compute_unitary</span><span class="p">(</span><span class="n">v_init</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">v_final</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_unitary</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[0. 1.]
 [1. 0.]]
</pre></div>
</div>
</div>
</div>
<p>Similarly, to transform orbitals X to orbitals C, if the unitary is known,</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_C</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">tu</span><span class="o">=</span><span class="n">my_unitary</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">new_C</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[2. 1.]
 [4. 3.]]
</pre></div>
</div>
</div>
</div>
<p>The majority of the time, the unitary is not known, and is the result of some optimization process.
The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.OrbitalOptimizer" title="inquanto.operators.OrbitalOptimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrbitalOptimizer</span></code></a> class in InQuanto is constructed with a black-box function which finds
the rotational unitary, given some variational criteria. For instance, we can perform a localization which depends on
some function <code class="code docutils literal notranslate"><span class="pre">localize</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrbitalOptimizer</span>
<span class="n">oo</span> <span class="o">=</span> <span class="n">OrbitalOptimizer</span><span class="p">(</span>
     <span class="n">v_init</span><span class="o">=</span><span class="n">initial_orbitals</span><span class="p">,</span>
     <span class="n">occ</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
     <span class="n">split_rotation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
     <span class="n">functional</span><span class="o">=</span><span class="n">localize</span><span class="p">,</span>
     <span class="n">minimizer</span><span class="o">=</span><span class="n">MinimizerScipy</span><span class="p">(),</span>
     <span class="n">reduce_free_parameters</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">final_orbitals</span><span class="p">,</span> <span class="n">minimising_unitary</span><span class="p">,</span> <span class="n">final_value</span> <span class="o">=</span> <span class="n">oo</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.OrbitalOptimizer" title="inquanto.operators.OrbitalOptimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrbitalOptimizer</span></code></a> object will try to retain orbital symmetries if <code class="code docutils literal notranslate"><span class="pre">point_group</span></code> and <code class="code docutils literal notranslate"><span class="pre">orb_irreps</span></code>
are both passed into the constructor. The function passed to the <code class="code docutils literal notranslate"><span class="pre">functional</span></code> argument must be a function of a 2D
array.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.OrbitalOptimizer" title="inquanto.operators.OrbitalOptimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrbitalOptimizer</span></code></a> is also a <code class="code docutils literal notranslate"><span class="pre">callable</span></code> object, but the callable execution of the optimization returns
only the optimized orbitals.  This is for compatibility with the <code class="code docutils literal notranslate"><span class="pre">transf</span></code> functionality in some extensions.</p>
</div>
<p>After the optimization, a report can be generated with the <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.OrbitalOptimizer.generate_report" title="inquanto.operators.OrbitalOptimizer.generate_report"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_report()</span></code></a> method.</p>
</section>
<section id="double-factorization">
<span id="id6"></span><h2>Double Factorization<a class="headerlink" href="#double-factorization" title="Permalink to this heading">¶</a></h2>
<p>An important restriction in near-term chemistry applications of quantum computing is the size of the Hamiltonian
operator, particularly the two-body interaction term:</p>
<div class="math-wrapper docutils container" id="equation-twobody">
<div class="math notranslate nohighlight" id="equation-twobody">
<span class="eqno">(79)<a class="headerlink" href="#equation-twobody" title="Permalink to this equation">¶</a></span>\[\hat H_2 = \frac{1}{2}\sum_{pqrs} h_{pqrs} a_p^\dagger a_r^\dagger a_s a_q,\]</div>
</div>
<p>which has <span class="math notranslate nohighlight">\(\mathcal{O}(N^4)\)</span> terms where <span class="math notranslate nohighlight">\(N\)</span> is the number of orbitals. Double factorization is a two-step, tensor
decomposition of the two-body integrals <span class="math notranslate nohighlight">\(h_{pqrs}\)</span>, which provides a systematic approach for truncating terms
in two-body Hamiltonians. Below, we provide an introduction to the essential equations, and an example of using this
decomposition strategy with InQuanto.</p>
<p>The first decomposition is given by:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-11">
<div class="math notranslate nohighlight" id="equation-manual-spaces-11">
<span class="eqno">(80)<a class="headerlink" href="#equation-manual-spaces-11" title="Permalink to this equation">¶</a></span>\[h_{pqrs} = \sum_t^{N_\gamma} V_{pq}^t \gamma^t V_{rs}^t,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(N_\gamma = N^2\)</span> for an exact decomposition. And the second:</p>
<div class="math-wrapper docutils container" id="equation-second">
<div class="math notranslate nohighlight" id="equation-second">
<span class="eqno">(81)<a class="headerlink" href="#equation-second" title="Permalink to this equation">¶</a></span>\[V_{pq}^t = \sum_u^{N_\lambda^t} U_{pu}^t \lambda_u^t U_{qu}^t.\]</div>
</div>
<p>for each <span class="math notranslate nohighlight">\(t\)</span>, where <span class="math notranslate nohighlight">\(N_\lambda^t = N\)</span> for an exact decomposition.</p>
<p>In InQuanto, the first factorization can be done either by eigenvalue decomposition or a pivoted, incomplete Cholesky
decomposition <span id="id7">[<a class="reference internal" href="../misc/bibliography.html#id78" title="Henrik Koch, Alfredo Sánchez de Merás, and Thomas Bondo Pedersen. Reduced scaling in electronic structure calculations using Cholesky decompositions. The Journal of Chemical Physics, 118(21):9481-9484, 06 2003. URL: https://doi.org/10.1063/1.1578621, arXiv:https://pubs.aip.org/aip/jcp/article-pdf/118/21/9481/19024657/9481\_1\_online.pdf, doi:10.1063/1.1578621.">39</a>, <a class="reference internal" href="../misc/bibliography.html#id79" title="Evgeny Epifanovsky, Dmitry Zuev, Xintian Feng, Kirill Khistyaev, Yihan Shao, and Anna I. Krylov. General implementation of the resolution-of-the-identity and Cholesky representations of electron repulsion integrals within coupled-cluster and equation-of-motion methods: Theory and benchmarks. The Journal of Chemical Physics, 139(13):134105, 10 2013. URL: https://doi.org/10.1063/1.4820484, arXiv:https://pubs.aip.org/aip/jcp/article-pdf/doi/10.1063/1.4820484/15465582/134105\_1\_online.pdf, doi:10.1063/1.4820484.">40</a>]</span>.
The second factorization step is always an eigenvalue decomposition, since the fully factorized operator must be
expressed in terms of unitary matrices to enable circuit-level rotations as shown below.</p>
<p>Each of the decompositions may be truncated to better control the size and scaling of number of terms in the
Hamiltonian. The magnitudes of the factors <span class="math notranslate nohighlight">\(\gamma^t\)</span> and <span class="math notranslate nohighlight">\(\lambda_u^t\)</span> determine the importance of their
corresponding terms in the decompositions and so terms can be systematically discarded based on their values.</p>
<p>The sums are truncated by discarding terms in ascending order of the factor magnitudes starting from the smallest such
that the sum of the <em>discarded</em> factors does not exceed some threshold <span id="id8">[<a class="reference internal" href="../misc/bibliography.html#id59" title="Mario Motta, Erika Ye, Jarrod R McClean, Zhendong Li, Austin J Minnich, Ryan Babbush, and Garnet Kin-Lic Chan. Low rank representations for quantum simulation of electronic structure. npj Quantum Information, 7(1):83, 2021.">41</a>]</span>:</p>
<div class="math-wrapper docutils container" id="equation-trunc">
<div class="math notranslate nohighlight" id="equation-trunc">
<span class="eqno">(82)<a class="headerlink" href="#equation-trunc" title="Permalink to this equation">¶</a></span>\[\sum_{t=N_\gamma +1}^{N^2} \left|\gamma^t\right| &lt; \varepsilon_1,\,\,\,\,\sum_{u=N_\lambda^t +1}^{N} \left|\lambda^t_u\right| &lt; \varepsilon_2.\]</div>
</div>
<p>In practice, the first decomposition can be truncated to <span class="math notranslate nohighlight">\(N_\gamma\sim \mathcal{O}(N)\)</span>, and the second
decomposition to <span class="math notranslate nohighlight">\(N_\lambda^t &lt; N\)</span>, helping to control the scaling of the number of terms in the two-body Hamiltonian.</p>
<p>Inserting the double factorized integrals into the two-body Hamiltonian <a class="reference internal" href="#equation-twobody">(79)</a>, after some work we arrive at the
diagonalized expression <span id="id9">[<a class="reference internal" href="../misc/bibliography.html#id59" title="Mario Motta, Erika Ye, Jarrod R McClean, Zhendong Li, Austin J Minnich, Ryan Babbush, and Garnet Kin-Lic Chan. Low rank representations for quantum simulation of electronic structure. npj Quantum Information, 7(1):83, 2021.">41</a>]</span>:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-12">
<div class="math notranslate nohighlight" id="equation-manual-spaces-12">
<span class="eqno">(83)<a class="headerlink" href="#equation-manual-spaces-12" title="Permalink to this equation">¶</a></span>\[\hat{H}_2 = \hat{S} + \frac{1}{2}\sum_t^{N_\gamma} \gamma^t \hat{R}(\textbf{U}_t) \left( \sum_u^{N_\lambda^t} \lambda_u^t a_u^\dagger a_u \right)^2 \hat{R}(\textbf{U}_t)^\dagger.\]</div>
</div>
<p>Here, <span class="math notranslate nohighlight">\(\hat{S}\)</span> is a one-body offset term which comes from rearranging the fermion operators:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-13">
<div class="math notranslate nohighlight" id="equation-manual-spaces-13">
<span class="eqno">(84)<a class="headerlink" href="#equation-manual-spaces-13" title="Permalink to this equation">¶</a></span>\[\hat{S} = -\frac{1}{2}\sum_{pq} \left( \sum_r h_{prrq}\right) a_p^\dagger a_q,\]</div>
</div>
<p>and <span class="math notranslate nohighlight">\(\hat{R}(\textbf{U}_t)\)</span> are Fock-space basis rotation operators, corresponding to the single particle basis
rotation matrices <span class="math notranslate nohighlight">\(\textbf{U}_t\)</span> (the eigenvector matrices of the second decomposition <a class="reference internal" href="#equation-second">(81)</a>). These
operators are given by the Thouless theorem <span id="id10">[<a class="reference internal" href="../misc/bibliography.html#id61" title="David J Thouless. Stability conditions and nuclear rotations in the hartree-fock theory. Nuclear Physics, 21:225–232, 1960.">42</a>]</span>:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-14">
<div class="math notranslate nohighlight" id="equation-manual-spaces-14">
<span class="eqno">(85)<a class="headerlink" href="#equation-manual-spaces-14" title="Permalink to this equation">¶</a></span>\[\hat{R}(\textbf{A}) = \exp\left[ \sum_{ij} \left[ \ln \textbf{A}\right]_{ij} a_i^\dagger a_j \right],\]</div>
</div>
<p>which are implemented at the circuit level with a Givens QR decomposition <span id="id11">[<a class="reference internal" href="../misc/bibliography.html#id60" title="Ian D Kivlichan, Jarrod McClean, Nathan Wiebe, Craig Gidney, Alán Aspuru-Guzik, Garnet Kin-Lic Chan, and Ryan Babbush. Quantum simulation of electronic structure with linear depth and connectivity. Physical review letters, 120(11):110501, 2018.">43</a>]</span>.
See below for an example, and <a class="reference internal" href="ansatze/basis_rotation.html#rotation"><span class="std std-ref">here</span></a> for more details.</p>
<p>We may similarly diagonalize the one-body integrals and <span class="math notranslate nohighlight">\(\hat{S}\)</span> operator:</p>
<div class="math-wrapper docutils container" id="equation-manual-spaces-15">
<div class="math notranslate nohighlight" id="equation-manual-spaces-15">
<span class="eqno">(86)<a class="headerlink" href="#equation-manual-spaces-15" title="Permalink to this equation">¶</a></span>\[\hat{H}_1' = \hat{H}_1 + \hat{S} = \sum_{pq} h_{pq}' a_p^\dagger a_q = \hat{R}(\textbf{W})\left( \sum_r \omega_r a_r^\dagger a_r \right)\hat{R}(\textbf{W})^\dagger\]</div>
</div>
<p>where all one-body-like terms have been consolidated into an effective one-body Hamiltonian <span class="math notranslate nohighlight">\(H_1'\)</span>. The full
Hamiltonian can then be written in this diagonal form as:</p>
<div class="math-wrapper docutils container" id="equation-full-diag">
<div class="math notranslate nohighlight" id="equation-full-diag">
<span class="eqno">(87)<a class="headerlink" href="#equation-full-diag" title="Permalink to this equation">¶</a></span>\[\begin{split}\hat{H} =\, &amp;\hat{H}_0 + \hat{R}(\textbf{W})\left( \sum_r \omega_r a_r^\dagger a_r \right)\hat{R}(\textbf{W})^\dagger \\
&amp;+  \frac{1}{2}\sum_t^{N_\gamma} \gamma^t \hat{R}(\textbf{U}_t) \left( \sum_u^{N_\lambda^t} \lambda_u^t a_u^\dagger a_u \right)^2 \hat{R}(\textbf{U}_t)^\dagger.\end{split}\]</div>
</div>
<p>In InQuanto, a <a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator" title="inquanto.operators.ChemistryRestrictedIntegralOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChemistryRestrictedIntegralOperator</span></code></a> object may be transformed into this
representation, a <code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleFactorizedHamiltonian</span></code> object, using the
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.double_factorize" title="inquanto.operators.ChemistryRestrictedIntegralOperator.double_factorize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">double_factorize()</span></code></a> method. We demonstrate this below
for H<sub>2</sub>O in the STO-3G basis:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.express</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_h5</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">ChemistryRestrictedIntegralOperator</span>

<span class="n">ham</span> <span class="o">=</span> <span class="n">load_h5</span><span class="p">(</span><span class="s2">&quot;h2o_sto3g.h5&quot;</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">hamiltonian_operator</span>
<span class="n">df_ham</span> <span class="o">=</span> <span class="n">ham</span><span class="o">.</span><span class="n">double_factorize</span><span class="p">(</span>
    <span class="n">tol1</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">gammas</span> <span class="o">=</span> <span class="n">df_ham</span><span class="o">.</span><span class="n">two_body</span><span class="o">.</span><span class="n">core_tensor</span><span class="o">.</span><span class="n">outer_params</span>
<span class="n">lambdas</span> <span class="o">=</span> <span class="n">df_ham</span><span class="o">.</span><span class="n">two_body</span><span class="o">.</span><span class="n">core_tensor</span><span class="o">.</span><span class="n">inner_params</span> <span class="c1"># these are padded to be of equal size</span>
<span class="n">N_gamma</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gammas</span><span class="p">)</span>
<span class="n">N_lambda</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lambdas</span><span class="p">]</span>

<span class="n">df_ham</span><span class="o">.</span><span class="n">n_orb</span><span class="p">,</span> <span class="n">N_gamma</span><span class="p">,</span> <span class="n">N_lambda</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>(7, 23, [7, 7, 5, 6, 2, 4, 6, 6, 4, 2, 4, 2, 4, 2, 4, 5, 3, 4, 2, 4, 2, 2, 3])
</pre></div>
</div>
</div>
</div>
<p>where we show the extent of the truncation (recall equation <a class="reference internal" href="#equation-trunc">(82)</a>). Default behavior is to consolidate and diagonalize all one-body terms, so
<code class="code docutils literal notranslate"><span class="pre">df_ham</span></code> represents a Hamiltonian of the form <a class="reference internal" href="#equation-full-diag">(87)</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.ChemistryRestrictedIntegralOperator.double_factorize" title="inquanto.operators.ChemistryRestrictedIntegralOperator.double_factorize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">double_factorize()</span></code></a> performs the
decomposition on the molecular orbital (MO) integrals. In classical literature, similar methods have been used to
reduce the memory storage requirements of two-body atomic orbital (AO) integrals <span id="id12">[<a class="reference internal" href="../misc/bibliography.html#id62" title="Bo Peng and Karol Kowalski. Highly efficient and scalable compound decomposition of two-electron integral tensor and its application in coupled cluster calculations. Journal of chemical theory and computation, 13(9):4179–4192, 2017.">44</a>]</span>. In InQuanto, the purpose
of this approach is to truncate the Hamiltonian for quantum simulation, so it should not be expected to reduce
classical memory requirements.</p>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code> method returns an iterator which generates the
<a class="reference internal" href="../api/inquanto/operators.html#inquanto.operators.FermionOperator" title="inquanto.operators.FermionOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionOperator</span></code></a> terms (the number operator sums in brackets of <a class="reference internal" href="#equation-full-diag">(87)</a>) alongside their corresponding
rotation matrices (<span class="math notranslate nohighlight">\(\textbf{W}\)</span> and <span class="math notranslate nohighlight">\(\textbf{U}_t\)</span>). For example, the one-body and the first two-body terms are:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_ham</span><span class="o">.</span><span class="n">fermion_operators</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="n">f2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_ham</span><span class="o">.</span><span class="n">fermion_operators</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
<span class="n">u1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_ham</span><span class="o">.</span><span class="n">rotation_matrices</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="n">u2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_ham</span><span class="o">.</span><span class="n">rotation_matrices</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One body operator: &quot;</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;One body rotation: &quot;</span><span class="p">,</span> <span class="n">u1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First two body operator: &quot;</span><span class="p">,</span> <span class="n">f2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First two body rotation: &quot;</span><span class="p">,</span> <span class="n">u2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>One body operator:  [{((0, 1), (0, 0)): np.float64(-35.15627858132068), ((1, 1), (1, 0)): np.float64(-35.15627858132068), ((2, 1), (2, 0)): np.float64(-8.99140515493988), ((3, 1), (3, 0)): np.float64(-8.99140515493988), ((4, 1), (4, 0)): np.float64(-8.30673410272335), ((5, 1), (5, 0)): np.float64(-8.30673410272335), ((6, 1), (6, 0)): np.float64(-8.057439359193436), ((7, 1), (7, 0)): np.float64(-8.057439359193436), ((8, 1), (8, 0)): np.float64(-8.028943982634141), ((9, 1), (9, 0)): np.float64(-8.028943982634141), ((10, 1), (10, 0)): np.float64(-4.621602713403972), ((11, 1), (11, 0)): np.float64(-4.621602713403972), ((12, 1), (12, 0)): np.float64(-4.593693566394927), ((13, 1), (13, 0)): np.float64(-4.593693566394927)}]
One body rotation:  [array([[-0.999,  0.028, -0.   ,  0.011,  0.   ,  0.014, -0.   ],
       [-0.031, -0.897,  0.   ,  0.046, -0.   , -0.438,  0.   ],
       [-0.   , -0.   , -0.775, -0.   , -0.   , -0.   , -0.632],
       [-0.011, -0.22 ,  0.   , -0.908, -0.   ,  0.355,  0.   ],
       [ 0.   ,  0.   ,  0.   ,  0.   , -1.   , -0.   ,  0.   ],
       [ 0.   , -0.   ,  0.632,  0.   , -0.   ,  0.   , -0.775],
       [ 0.006, -0.382, -0.   ,  0.416,  0.   ,  0.825,  0.   ]])]
First two body operator:  (2.4448764396689815, F0^ F0  F0^ F0 ), (2.4448764396689815, F0^ F0  F1^ F1 ), (0.6036682667825736, F0^ F0  F2^ F2 ), (0.6036682667825736, F0^ F0  F3^ F3 ), (0.6032107009666192, F0^ F0  F4^ F4 ), (0.6032107009666192, F0^ F0  F5^ F5 ), (0.5661066153622433, F0^ F0  F6^ F6 ), (0.5661066153622433, F0^ F0  F7^ F7 ), (0.5485420002371266, F0^ F0  F8^ F8 ), (0.5485420002371266, F0^ F0  F9^ F9 ), (0.23407908501568664, F0^ F0  F10^ F10 ), (0.23407908501568664, F0^ F0  F11^ F11 ), (0.22952218815953337, F0^ F0  F12^ F12 ), (0.22952218815953337, F0^ F0  F13^ F13 ), (2.4448764396689815, F1^ F1  F0^ F0 ), (2.4448764396689815, F1^ F1  F1^ F1 ), (0.6036682667825736, F1^ F1  F2^ F2 ), (0.6036682667825736, F1^ F1  F3^ F3 ), (0.6032107009666192, F1^ F1  F4^ F4 ), (0.6032107009666192, F1^ F1  F5^ F5 ), (0.5661066153622433, F1^ F1  F6^ F6 ), (0.5661066153622433, F1^ F1  F7^ F7 ), (0.5485420002371266, F1^ F1  F8^ F8 ), (0.5485420002371266, F1^ F1  F9^ F9 ), (0.23407908501568664, F1^ F1  F10^ F10 ), (0.23407908501568664, F1^ F1  F11^ F11 ), (0.22952218815953337, F1^ F1  F12^ F12 ), (0.22952218815953337, F1^ F1  F13^ F13 ), (0.6036682667825736, F2^ F2  F0^ F0 ), (0.6036682667825736, F2^ F2  F1^ F1 ), (0.1490526762037985, F2^ F2  F2^ F2 ), (0.1490526762037985, F2^ F2  F3^ F3 ), (0.14893969791230924, F2^ F2  F4^ F4 ), (0.14893969791230924, F2^ F2  F5^ F5 ), (0.1397782700855605, F2^ F2  F6^ F6 ), (0.1397782700855605, F2^ F2  F7^ F7 ), (0.1354413634847845, F2^ F2  F8^ F8 ), (0.1354413634847845, F2^ F2  F9^ F9 ), (0.0577968331031903, F2^ F2  F10^ F10 ), (0.0577968331031903, F2^ F2  F11^ F11 ), (0.056671682571070386, F2^ F2  F12^ F12 ), (0.056671682571070386, F2^ F2  F13^ F13 ), (0.6036682667825736, F3^ F3  F0^ F0 ), (0.6036682667825736, F3^ F3  F1^ F1 ), (0.1490526762037985, F3^ F3  F2^ F2 ), (0.1490526762037985, F3^ F3  F3^ F3 ), (0.14893969791230924, F3^ F3  F4^ F4 ), (0.14893969791230924, F3^ F3  F5^ F5 ), (0.1397782700855605, F3^ F3  F6^ F6 ), (0.1397782700855605, F3^ F3  F7^ F7 ), (0.1354413634847845, F3^ F3  F8^ F8 ), (0.1354413634847845, F3^ F3  F9^ F9 ), (0.0577968331031903, F3^ F3  F10^ F10 ), (0.0577968331031903, F3^ F3  F11^ F11 ), (0.056671682571070386, F3^ F3  F12^ F12 ), (0.056671682571070386, F3^ F3  F13^ F13 ), (0.6032107009666192, F4^ F4  F0^ F0 ), (0.6032107009666192, F4^ F4  F1^ F1 ), (0.14893969791230924, F4^ F4  F2^ F2 ), (0.14893969791230924, F4^ F4  F3^ F3 ), (0.14882680525560812, F4^ F4  F4^ F4 ), (0.14882680525560812, F4^ F4  F5^ F5 ), (0.13967232156760168, F4^ F4  F6^ F6 ), (0.13967232156760168, F4^ F4  F7^ F7 ), (0.13533870223620306, F4^ F4  F8^ F8 ), (0.13533870223620306, F4^ F4  F9^ F9 ), (0.05775302451401368, F4^ F4  F10^ F10 ), (0.05775302451401368, F4^ F4  F11^ F11 ), (0.05662872681854202, F4^ F4  F12^ F12 ), (0.05662872681854202, F4^ F4  F13^ F13 ), (0.6032107009666192, F5^ F5  F0^ F0 ), (0.6032107009666192, F5^ F5  F1^ F1 ), (0.14893969791230924, F5^ F5  F2^ F2 ), (0.14893969791230924, F5^ F5  F3^ F3 ), (0.14882680525560812, F5^ F5  F4^ F4 ), (0.14882680525560812, F5^ F5  F5^ F5 ), (0.13967232156760168, F5^ F5  F6^ F6 ), (0.13967232156760168, F5^ F5  F7^ F7 ), (0.13533870223620306, F5^ F5  F8^ F8 ), (0.13533870223620306, F5^ F5  F9^ F9 ), (0.05775302451401368, F5^ F5  F10^ F10 ), (0.05775302451401368, F5^ F5  F11^ F11 ), (0.05662872681854202, F5^ F5  F12^ F12 ), (0.05662872681854202, F5^ F5  F13^ F13 ), (0.5661066153622433, F6^ F6  F0^ F0 ), (0.5661066153622433, F6^ F6  F1^ F1 ), (0.1397782700855605, F6^ F6  F2^ F2 ), (0.1397782700855605, F6^ F6  F3^ F3 ), (0.13967232156760168, F6^ F6  F4^ F4 ), (0.13967232156760168, F6^ F6  F5^ F5 ), (0.13108093920700759, F6^ F6  F6^ F6 ), (0.13108093920700759, F6^ F6  F7^ F7 ), (0.12701388507810177, F6^ F6  F8^ F8 ), (0.12701388507810177, F6^ F6  F9^ F9 ), (0.054200578972106485, F6^ F6  F10^ F10 ), (0.054200578972106485, F6^ F6  F11^ F11 ), (0.053145437937600445, F6^ F6  F12^ F12 ), (0.053145437937600445, F6^ F6  F13^ F13 ), (0.5661066153622433, F7^ F7  F0^ F0 ), (0.5661066153622433, F7^ F7  F1^ F1 ), (0.1397782700855605, F7^ F7  F2^ F2 ), (0.1397782700855605, F7^ F7  F3^ F3 ), (0.13967232156760168, F7^ F7  F4^ F4 ), (0.13967232156760168, F7^ F7  F5^ F5 ), (0.13108093920700759, F7^ F7  F6^ F6 ), (0.13108093920700759, F7^ F7  F7^ F7 ), (0.12701388507810177, F7^ F7  F8^ F8 ), (0.12701388507810177, F7^ F7  F9^ F9 ), (0.054200578972106485, F7^ F7  F10^ F10 ), (0.054200578972106485, F7^ F7  F11^ F11 ), (0.053145437937600445, F7^ F7  F12^ F12 ), (0.053145437937600445, F7^ F7  F13^ F13 ), (0.5485420002371266, F8^ F8  F0^ F0 ), (0.5485420002371266, F8^ F8  F1^ F1 ), (0.1354413634847845, F8^ F8  F2^ F2 ), (0.1354413634847845, F8^ F8  F3^ F3 ), (0.13533870223620306, F8^ F8  F4^ F4 ), (0.13533870223620306, F8^ F8  F5^ F5 ), (0.12701388507810177, F8^ F8  F6^ F6 ), (0.12701388507810177, F8^ F8  F7^ F7 ), (0.12307301961848317, F8^ F8  F8^ F8 ), (0.12307301961848317, F8^ F8  F9^ F9 ), (0.05251889519846896, F8^ F8  F10^ F10 ), (0.05251889519846896, F8^ F8  F11^ F11 ), (0.051496492071754295, F8^ F8  F12^ F12 ), (0.051496492071754295, F8^ F8  F13^ F13 ), (0.5485420002371266, F9^ F9  F0^ F0 ), (0.5485420002371266, F9^ F9  F1^ F1 ), (0.1354413634847845, F9^ F9  F2^ F2 ), (0.1354413634847845, F9^ F9  F3^ F3 ), (0.13533870223620306, F9^ F9  F4^ F4 ), (0.13533870223620306, F9^ F9  F5^ F5 ), (0.12701388507810177, F9^ F9  F6^ F6 ), (0.12701388507810177, F9^ F9  F7^ F7 ), (0.12307301961848317, F9^ F9  F8^ F8 ), (0.12307301961848317, F9^ F9  F9^ F9 ), (0.05251889519846896, F9^ F9  F10^ F10 ), (0.05251889519846896, F9^ F9  F11^ F11 ), (0.051496492071754295, F9^ F9  F12^ F12 ), (0.051496492071754295, F9^ F9  F13^ F13 ), (0.23407908501568664, F10^ F10  F0^ F0 ), (0.23407908501568664, F10^ F10  F1^ F1 ), (0.0577968331031903, F10^ F10  F2^ F2 ), (0.0577968331031903, F10^ F10  F3^ F3 ), (0.05775302451401368, F10^ F10  F4^ F4 ), (0.05775302451401368, F10^ F10  F5^ F5 ), (0.054200578972106485, F10^ F10  F6^ F6 ), (0.054200578972106485, F10^ F10  F7^ F7 ), (0.05251889519846896, F10^ F10  F8^ F8 ), (0.05251889519846896, F10^ F10  F9^ F9 ), (0.022411364906931505, F10^ F10  F10^ F10 ), (0.022411364906931505, F10^ F10  F11^ F11 ), (0.02197507527311114, F10^ F10  F12^ F12 ), (0.02197507527311114, F10^ F10  F13^ F13 ), (0.23407908501568664, F11^ F11  F0^ F0 ), (0.23407908501568664, F11^ F11  F1^ F1 ), (0.0577968331031903, F11^ F11  F2^ F2 ), (0.0577968331031903, F11^ F11  F3^ F3 ), (0.05775302451401368, F11^ F11  F4^ F4 ), (0.05775302451401368, F11^ F11  F5^ F5 ), (0.054200578972106485, F11^ F11  F6^ F6 ), (0.054200578972106485, F11^ F11  F7^ F7 ), (0.05251889519846896, F11^ F11  F8^ F8 ), (0.05251889519846896, F11^ F11  F9^ F9 ), (0.022411364906931505, F11^ F11  F10^ F10 ), (0.022411364906931505, F11^ F11  F11^ F11 ), (0.02197507527311114, F11^ F11  F12^ F12 ), (0.02197507527311114, F11^ F11  F13^ F13 ), (0.22952218815953337, F12^ F12  F0^ F0 ), (0.22952218815953337, F12^ F12  F1^ F1 ), (0.056671682571070386, F12^ F12  F2^ F2 ), (0.056671682571070386, F12^ F12  F3^ F3 ), (0.05662872681854202, F12^ F12  F4^ F4 ), (0.05662872681854202, F12^ F12  F5^ F5 ), (0.053145437937600445, F12^ F12  F6^ F6 ), (0.053145437937600445, F12^ F12  F7^ F7 ), (0.051496492071754295, F12^ F12  F8^ F8 ), (0.051496492071754295, F12^ F12  F9^ F9 ), (0.02197507527311114, F12^ F12  F10^ F10 ), (0.02197507527311114, F12^ F12  F11^ F11 ), (0.02154727903741131, F12^ F12  F12^ F12 ), (0.02154727903741131, F12^ F12  F13^ F13 ), (0.22952218815953337, F13^ F13  F0^ F0 ), (0.22952218815953337, F13^ F13  F1^ F1 ), (0.056671682571070386, F13^ F13  F2^ F2 ), (0.056671682571070386, F13^ F13  F3^ F3 ), (0.05662872681854202, F13^ F13  F4^ F4 ), (0.05662872681854202, F13^ F13  F5^ F5 ), (0.053145437937600445, F13^ F13  F6^ F6 ), (0.053145437937600445, F13^ F13  F7^ F7 ), (0.051496492071754295, F13^ F13  F8^ F8 ), (0.051496492071754295, F13^ F13  F9^ F9 ), (0.02197507527311114, F13^ F13  F10^ F10 ), (0.02197507527311114, F13^ F13  F11^ F11 ), (0.02154727903741131, F13^ F13  F12^ F12 ), (0.02154727903741131, F13^ F13  F13^ F13 )
First two body rotation:  [[-0.99   0.115 -0.     0.048  0.     0.062 -0.   ]
 [ 0.085  0.564 -0.    -0.464 -0.     0.677 -0.   ]
 [-0.    -0.    -0.677  0.    -0.    -0.    -0.736]
 [-0.    -0.     0.    -0.    -1.     0.     0.   ]
 [-0.11  -0.645  0.    -0.756  0.     0.033 -0.   ]
 [ 0.    -0.     0.736  0.    -0.     0.    -0.677]
 [ 0.009 -0.502 -0.     0.459  0.     0.733  0.   ]]
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The corresponding rotation matrix for the constant energy term is the identity.</p>
</div>
<p>Circuit representations of the rotation operators may be computed using the <a class="reference internal" href="../api/inquanto/ansatz.html#inquanto.ansatzes.restricted_basis_rotation_to_circuit" title="inquanto.ansatzes.restricted_basis_rotation_to_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inquanto.ansatzes.restricted_basis_rotation_to_circuit()</span></code></a> method,
which uses the <a class="reference internal" href="../api/inquanto/ansatz.html#inquanto.ansatzes.RealRestrictedBasisRotationAnsatz" title="inquanto.ansatzes.RealRestrictedBasisRotationAnsatz"><code class="xref py py-class docutils literal notranslate"><span class="pre">RealRestrictedBasisRotationAnsatz</span></code></a> to encode the rotations in the Jordan-Wigner picture
(see <a class="reference internal" href="ansatze/basis_rotation.html#rotation"><span class="std std-ref">here</span></a> for more information). For example, below we construct a computable for the expectation value of a single term in
<a class="reference internal" href="#equation-full-diag">(87)</a> with a UCCSD ansatz:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.mappings</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitMappingJordanWigner</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.ansatzes</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionSpaceAnsatzUCCSD</span><span class="p">,</span> <span class="n">rotate_ansatz_generalized</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">FermionState</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inquanto.computables</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExpectationValue</span>

<span class="n">jw</span> <span class="o">=</span> <span class="n">QubitMappingJordanWigner</span><span class="p">()</span>

<span class="n">ansatz</span> <span class="o">=</span> <span class="n">FermionSpaceAnsatzUCCSD</span><span class="p">(</span> <span class="c1"># |psi&gt;</span>
    <span class="n">fermion_space</span><span class="o">=</span><span class="mi">7</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fermion_state</span><span class="o">=</span><span class="n">FermionState</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
    <span class="n">qubit_mapping</span><span class="o">=</span><span class="n">jw</span>
<span class="p">)</span>

<span class="n">rotation_matrices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_ham</span><span class="o">.</span><span class="n">rotation_matrices</span><span class="p">())</span>
<span class="n">df_operators</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_ham</span><span class="o">.</span><span class="n">fermion_operators</span><span class="p">())</span>
<span class="n">rotated_ansatz</span> <span class="o">=</span> <span class="n">rotate_ansatz_generalized</span><span class="p">(</span><span class="n">ansatz</span><span class="p">,</span> <span class="n">rotation_matrices</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="n">rotated_operator</span> <span class="o">=</span> <span class="n">df_operators</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">qubit_encode</span><span class="p">()</span>

<span class="n">term_computable</span> <span class="o">=</span> <span class="n">ExpectationValue</span><span class="p">(</span><span class="n">rotated_ansatz</span><span class="p">,</span> <span class="n">rotated_operator</span><span class="p">)</span>  <span class="c1"># &lt;psi| R(U) X R(U)^ |psi&gt;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>This expectation value evaluation needs to be performed by summing every required term in the double factorized Hamiltonian. This is best be accomplished with <a class="reference internal" href="../api/inquanto/computables.html#inquanto.computables.composite.ExpectationValueSumComputable" title="inquanto.computables.composite.ExpectationValueSumComputable"><code class="xref py py-class docutils literal notranslate"><span class="pre">inquanto.computables.composite.ExpectationValueSumComputable</span></code></a>, and is demonstrated in the double factorization <a class="reference internal" href="../tutorials/examples_overview.html#examples-overview"><span class="std std-ref">operators examples</span></a>.
Note the transpose of the rotation matrix: <span class="math notranslate nohighlight">\(\hat{R}(\textbf{U}_t)^\dagger = \hat{R}(\textbf{U}_t^T)\)</span>, which is true for a real-valued rotation matrix.</p>
<blockquote>
<div></div></blockquote>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="ansatzae_overview.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Ansatzes</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="errmit.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Noise mitigation</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
              Copyright &#169; 2024 Quantinuum Ltd. All rights reserved.
            </div>
            <div class="terms" style="display:flex; gap:0.5rem; align-items:center; margin: 0.25rem 0rem;">
              <a href="https://www.quantinuum.com/privacy-statement" target="_blank">Privacy Statement</a>
              <div role="separator">/</div>
              <a href="https://www.quantinuum.com/cookie-notice" target="_blank">Cookie Notice</a>
              <div role="separator">/</div>
              <a href="https://www.quantinuum.com/terms-conditions" target="_blank">Terms and Conditions</a>
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Spaces, Operators, and States</a><ul>
<li><a class="reference internal" href="#fermionic-spaces">Fermionic Spaces</a><ul>
<li><a class="reference internal" href="#the-fermionspace-class">The <code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSpace</span></code> Class</a></li>
<li><a class="reference internal" href="#fermion-operators-states">Fermion Operators &amp; States</a></li>
</ul>
</li>
<li><a class="reference internal" href="#qubit-spaces-operators-and-states">Qubit spaces, operators and states</a><ul>
<li><a class="reference internal" href="#qubit-operators">Qubit Operators</a></li>
<li><a class="reference internal" href="#qubit-states-expectation-values">Qubit States &amp; Expectation Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fermion-to-qubit-mapping">Fermion-to-Qubit Mapping</a><ul>
<li><a class="reference internal" href="#custom-mappings">Custom mappings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#integral-operators">Integral Operators</a><ul>
<li><a class="reference internal" href="#interfacing-with-quantum-chemistry-packages-via-fcidump">Interfacing with Quantum Chemistry Packages via FCIDUMP</a></li>
<li><a class="reference internal" href="#unrestricted-integrals">Unrestricted integrals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orbital-transformation-and-optimization">Orbital Transformation and Optimization</a></li>
<li><a class="reference internal" href="#double-factorization">Double Factorization</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/jquery.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    </body>
</html>