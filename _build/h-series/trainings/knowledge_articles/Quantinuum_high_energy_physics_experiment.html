<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YPQ1FTGDL3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-YPQ1FTGDL3');
    </script>
    <link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="Automatic Leakage Error Detection" href="Quantinuum_leakage_detection.html" /><link rel="prev" title="Quantum Chemistry Calculations with Arbitrary Angle 2-Qubit Gates" href="Quantinuum_chemistry_chemically_aware_ucc.html" />

    <link rel="shortcut icon" href="../../_static/quantinuum_favicon.svg"/><!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
        <title>High Energy Physics: Implementing \(SU(2)\) Lattice Gauge Theory Trotter Circuits - H-Series</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=2d233a06" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style>
<link rel="stylesheet" href="../../_static/tokens.css"/>
<link rel="stylesheet" href="../../_static/styles.css"/>
<link rel="stylesheet" href="../../_static/tailwind.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="preload"
as="style">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">

<style>  
  .sidebar-sticky {
    top: calc(3.5rem - 0px);
    height: calc(100vh - 3.5rem);
  }
  
  @media (min-width: 97em) {
    html {
      font-size: 100% !important;
    }
  }
  
</style>
</head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>
<!-- <script type="text/javascript" src="../../_static/syncTheme.global.js" ></script> -->
 <!--Force light mode -->
 <script>document.body.setAttribute('data-theme','light')</script>
<nav style="position:fixed;top:0;z-index:1021;width:100%;">
    <div class="nexus-nav"></div>
</nav>
<script type="text/javascript" src="../../_static/injectNav.global.js"></script>
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">H-Series</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../_static/h-series.svg" alt="Logo"/>
  </div>
  
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">User Guides</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../user_guide/hardware_user_guide/access.html">Hardware User Guide</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Hardware User Guide</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/hardware_user_guide/access.html">H-Series Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/hardware_user_guide/system_operation.html">System Operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/hardware_user_guide/workflow.html">H-Series Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/hardware_user_guide/fair_queue.html">Fair Queue</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../user_guide/emulator_user_guide/introduction.html">Emulator User Guide</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Emulator User Guide</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/emulator_user_guide/introduction.html">Quantinuum Emulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/emulator_user_guide/noise_model.html">Noise Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/emulator_user_guide/emulators/h1_emulators.html">H1 Emulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/emulator_user_guide/emulators/h2_emulators.html">H2 Emulators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://docs.quantinuum.com/nexus/user_guide/user_guide.html">Nexus User Guide</a></li>
<li class="toctree-l1"><a class="reference external" href="https://docs.quantinuum.com/nexus/admin_guide/admin_guide.html">Nexus Admin Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Trainings</span></p>
<ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../getting_started/getting_started_index.html">Getting Started</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Getting Started</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/getting_started_index.html">Unique Capabilities</a></li>
<li class="toctree-l2"><a class="reference external" href="https://docs.quantinuum.com/nexus/trainings/getting_started.html">Quantinuum Nexus</a></li>
<li class="toctree-l2"><a class="reference external" href="https://docs.quantinuum.com/tket/user-guide/index.html">TKET</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/emulators.html">Quantinuum Emulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/mcmr.html">Mid-Circuit Measurement &amp; Reset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/arbitrary_angle_2_qubit_gates.html">Native Arbitrary Angle Hardware Gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/conditional_operations_and_classical_logic.html">Conditional Operations &amp; Classical Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/batch_jobs.html">Batch Jobs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/api_options.html">Quantinuum Systems API Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/access_systems_with_qiskit.html">Using Qiskit with Quantinuum Devices</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../getting_started/qec_decoder_toolkit/qec_decoder_toolkit.html">QEC Decoder Toolkit</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of QEC Decoder Toolkit</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/qec_decoder_toolkit/qec_decoder_toolkit.html">QEC Decoder Toolkit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/qec_decoder_toolkit/repeat_until_success/rus_index.html">Repeat Until Success</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/qec_decoder_toolkit/repetition_code/repetition_code_index.html">Repetition Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/qec_decoder_toolkit/surface_code/surface_code_index.html">Surface Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/pytket_quantinuum/pytket_quantinuum.html"><code class="docutils literal notranslate"><span class="pre">pytket-quantinuum</span></code></a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="ka_index.html">Knowledge Articles</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Knowledge Articles</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Quantinuum_chemistry_chemically_aware_ucc.html">Quantum Chemistry Calculations with Arbitrary Angle 2-Qubit Gates</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">High Energy Physics: Implementing <span class="math notranslate nohighlight">\(SU(2)\)</span> Lattice Gauge Theory Trotter Circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="Quantinuum_leakage_detection.html">Automatic Leakage Error Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="Quantinuum_toric_code.html">Topological Order from Measurements and Feed-Forward</a></li>
<li class="toctree-l2"><a class="reference internal" href="Quantinuum_variational_experiment_with_batching.html">Variational Experiment with Batching</a></li>
<li class="toctree-l2"><a class="reference internal" href="Quantinuum_n56_ghz_state_fidelity.html">GHZ State Fidelity</a></li>
<li class="toctree-l2"><a class="reference internal" href="circuit_stitching.html">Circuit Stitching</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../support/product_change_notifications.html">Product Change Notifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support/troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support/faqs.html">FAQs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support/hseries_citations.html">How to Cite H-Series</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          

<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="high-energy-physics-implementing-su-2-lattice-gauge-theory-trotter-circuits">
<h1>High Energy Physics: Implementing <span class="math notranslate nohighlight">\(SU(2)\)</span> Lattice Gauge Theory Trotter Circuits<a class="headerlink" href="#high-energy-physics-implementing-su-2-lattice-gauge-theory-trotter-circuits" title="Link to this heading">¶</a></h1>
<p>Quantum computers have the ability to tackle problems beyond the reach of classical systems. One such application lies in the realm of quantum field theories, where lattice gauge theories provide a rigorous framework to derive non-perturbative results. Before diving in, you may find it helpful to review the <a class="reference internal" href="#hep-definitions"><span class="std std-ref">Definitions</span></a> at the end of this article if you’re unfamiliar with high energy physics.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Lattice gauge theory (LGT) is a vital computational tool in quantum field theory, enabling the acquisition of rigorous results without relying on perturbation theory. It’s particularly significant in the context of quantum chromodynamics (QCD), where lattice computations have been instrumental in uncovering new properties of known hadrons, evaluating the likelihood of undiscovered hadrons, and providing critical insights for the search for new physics beyond the standard model.</p>
<p>Typically, LGT studies are conducted in Euclidean spacetime, where time is treated as an imaginary component. This approach is effective for many observables, but it limits the ability to analyze real-time dynamics. However, a Hamiltonian formulation in real-time could overcome this limitation, given adequate computing resources. This is where the potential of future quantum computers becomes particularly intriguing. Quantum computers could handle and evolve quantum states far beyond the capabilities of classical computers, thus offering a promising avenue for exploring real-time dynamics within LGT.</p>
<p>The paper <a class="reference external" href="http://arxiv.org/abs/2205.09247">Self-mitigating Trotter circuits for SU(2) lattice gauge theory on a quantum computer</a> by Rahman, Lewis, Mendicelli, and Powell delves into the implementation of SU(2) lattice gauge theory in Minkowski spacetime using quantum computers, showcasing the real-time evolution of excitations across a lattice. While the theoretical foundations laid out in the paper are robust, practical implementation on contemporary quantum hardware requires specialized techniques and considerations.</p>
<p>This knowledge article, complete with detailed code, explores the implementation of methods described in this paper on the Quantinuum H-Series devices. Utilizing TKET, we detail the process of defining the SU(2) 2-Plaquette (2-qubit) Model Hamiltonian, setting up quantum circuits, and employing Trotterization to simulate the quantum dynamics of the system. For a single Trotter step, we simulate the ideal execution of a quantum circuit using a statevector simulator. The two Trotter step case is executed on the Quantinuum H1-2 emulator, and we also demonstrate an example of symbolic circuit construction for these circuits. The final section details the implementation of the SU(2) 5-Plaquette (five-qubit) Model Hamiltonian using the <code class="docutils literal notranslate"><span class="pre">Qiskit</span></code> library.</p>
</section>
<section id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Link to this heading">¶</a></h2>
<p>This notebook was generated using <code class="docutils literal notranslate"><span class="pre">pytket=1.23.0</span></code>, <code class="docutils literal notranslate"><span class="pre">pytket-quantinuum=0.26.0</span></code>, and <code class="docutils literal notranslate"><span class="pre">pytket-qiskit=0.47.0</span></code>.</p>
<p>First, we import the libraries and modules we will use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Pauli</span></code> utilities and <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> are used for Hamiltonian representation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Circuit</span></code> utilities from <code class="docutils literal notranslate"><span class="pre">pytket</span></code> are used for constructing and analyzing quantum circuits.</p></li>
<li><p>Additional utilities are used for generating term sequences and gate statistics.</p></li>
<li><p>Standard libraries are used for numerical operations and visualization.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.pauli</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pauli</span><span class="p">,</span> <span class="n">QubitPauliString</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitPauliOperator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.circuit</span><span class="w"> </span><span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">CircBox</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">gen_term_sequence_circuit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.utils.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">gate_counts</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpType</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">expm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Uncomment to verify installation of pytket extensions: pytket-quantinuum and pytket-qiskit.</span>
<span class="c1"># %pip show pytket pytket-quantinuum pytket-qiskit</span>
</pre></div>
</div>
</div>
</div>
<p><em>Note:</em> Plotting circuits requires an internet connection. An alternative for displaying circuits is the <code class="docutils literal notranslate"><span class="pre">pytket-offline-display</span></code> package for rendering circuits offline with no internet connection, for details see <a class="reference external" href="https://github.com/CQCL/pytket-offline-renderer">here</a>.</p>
</section>
<section id="hamiltonian-formulation">
<h2>Hamiltonian Formulation<a class="headerlink" href="#hamiltonian-formulation" title="Link to this heading">¶</a></h2>
<p>In quantum mechanics, the Hamiltonian operator plays a pivotal role as it represents the total energy of a system and governs how quantum states evolve with time. The time evolution of a quantum state, denoted as <span class="math notranslate nohighlight">\(|ψ(t)⟩\)</span>, is described by the Schrödinger equation:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[
i \hbar \frac{{d|\psi(t)\rangle}}{{dt}} = \hat{H}|\psi(t)\rangle
\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(i\)</span> stands for the imaginary unit, <span class="math notranslate nohighlight">\(\hbar\)</span> denotes the reduced Planck constant, and <span class="math notranslate nohighlight">\(\hat{H}\)</span> signifies the Hamiltonian operator of the system. In the realm of quantum simulations, particularly those involving lattice gauge theories, the Hamiltonian is indispensable. It not only elucidates the system’s dynamics but also forms the foundation for creating quantum circuits that simulate this evolution.</p>
</section>
<section id="su-2-2-plaquette-model-hamiltonian">
<h2>SU(2) 2-Plaquette Model Hamiltonian<a class="headerlink" href="#su-2-2-plaquette-model-hamiltonian" title="Link to this heading">¶</a></h2>
<p>The SU(2) 2-plaquette model offers a streamlined representation of lattice gauge theories. The associated Hamiltonian for this model encapsulates the core dynamics of the system, making it apt for simulation on quantum hardware. The Hamiltonian’s general expression is:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[
\hat{H} = \sum_{i,j} J_{ij} \sigma_i^a \sigma_j^a + \sum_i h_i \sigma_i^z
\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(J_{ij}\)</span> represents interaction coefficients between lattice sites <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>, <span class="math notranslate nohighlight">\(\sigma_i^a\)</span> and <span class="math notranslate nohighlight">\(\sigma_j^a\)</span> are the Pauli matrices for site <span class="math notranslate nohighlight">\(i\)</span> or <span class="math notranslate nohighlight">\(j\)</span>, with <span class="math notranslate nohighlight">\(a\)</span> taking values <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> or <span class="math notranslate nohighlight">\(z\)</span>, and <span class="math notranslate nohighlight">\(h_i\)</span> are the external field terms for site <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>Here we show the 2-qubit Hamiltonian for the SU(2) 2-plaquette model:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\frac{2}{g^2} H=\left(\begin{array}{cccc}
0 &amp; -2 x &amp; -2 x &amp; 0 \\
-2 x &amp; 3 &amp; 0 &amp; -x \\
-2 x &amp; 0 &amp; 3 &amp; -x \\
0 &amp; -x &amp; -x &amp; \frac{9}{2}
\end{array}\right)= &amp; \frac{3}{8}\left(7 I_0 \otimes I_1-3 Z_0 \otimes I_1-Z_0 \otimes Z_1-3 I_0 \otimes Z_1\right) \\
&amp; -\frac{x}{2}\left(3 X_0 \otimes I_1+X_0 \otimes Z_1\right)-\frac{x}{2}\left(3 I_0 \otimes X_1+Z_0 \otimes X_1\right)
\end{aligned}
\end{split}\]</div>
</div>
<ul class="simple">
<li><p>The matrix form represents the action of the Hamiltonian on a 2-qubit system.</p></li>
<li><p>The expanded form shows the Hamiltonian in terms of tensor products of Pauli matrices, providing insight into the system’s dynamics and interactions.</p></li>
</ul>
<p>This Hamiltonian encapsulates the dynamics of the system and serves as the foundation for subsequent quantum simulations. Specifically, the terms associated with Pauli <span class="math notranslate nohighlight">\(Z\)</span> matrices, like <span class="math notranslate nohighlight">\(Z_0\)</span> and <span class="math notranslate nohighlight">\(Z_1\)</span>, capture the on-site energies and interactions between the qubits. The terms involving the Pauli <span class="math notranslate nohighlight">\(X\)</span> matrices, such as <span class="math notranslate nohighlight">\(X_0\)</span> and <span class="math notranslate nohighlight">\(X_1\)</span>, represent the interactions influenced by external fields parameterized by <span class="math notranslate nohighlight">\(x\)</span>. This Hamiltonian provides a framework for analyzing and simulating the dynamics of the SU(2) 2-plaquette model, making it a cornerstone for the quantum simulations presented in the paper and this notebook.</p>
</section>
<section id="implementation-of-the-su-2-2-plaquette-model-hamiltonian">
<h2>Implementation of the SU(2) 2-Plaquette Model Hamiltonian<a class="headerlink" href="#implementation-of-the-su-2-2-plaquette-model-hamiltonian" title="Link to this heading">¶</a></h2>
<p>The Hamiltonian for the SU(2) 2-plaquette model is implemented in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> in this notebook using the <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> to write the operator on qubits and <code class="docutils literal notranslate"><span class="pre">QubitPauliString</span></code> to represent the individual Pauli string terms. Here we use <span class="math notranslate nohighlight">\(x = 2\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">QubitPauliOperator</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="n">QubitPauliString</span><span class="p">([],</span> <span class="p">[]):</span> <span class="o">+</span><span class="mi">7</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">]):</span> <span class="o">-</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">]):</span> <span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">]):</span> <span class="o">-</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">]):</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">]):</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">]):</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">]):</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can display the <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> representation of the Hamiltonian:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>You can also visualize the non-zero elements of the Hamiltonian matrix using a <code class="docutils literal notranslate"><span class="pre">spy</span></code> plot from the <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> library , shedding light on its non-zero components and overall structure:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">spy</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">to_sparse_matrix</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<section id="matrix-formulation">
<h3>Matrix Formulation<a class="headerlink" href="#matrix-formulation" title="Link to this heading">¶</a></h3>
<p>We can also convert the Hamiltonian <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> representation to a dense matrix and extract the Hamiltonian matrix elements. This transformation caters to computational tasks and subsequent quantum simulations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hm</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">to_sparse_matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
<span class="n">hm</span><span class="o">.</span><span class="n">real</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-evolution-operator">
<h3>Time Evolution Operator<a class="headerlink" href="#time-evolution-operator" title="Link to this heading">¶</a></h3>
<p>To simulate the time evolution of the quantum system, we compute the matrix exponential of the Hamiltonian matrix. This process represents how the quantum state evolves over a specific time interval. For instance, a factor like <span class="math notranslate nohighlight">\(0.1\)</span> can be interpreted as a discrete time step in the system’s evolution.</p>
<p>In our implementation, we use the <code class="docutils literal notranslate"><span class="pre">expm</span></code> function to calculate the matrix exponential of the Hamiltonian for a time step of <span class="math notranslate nohighlight">\(0.1\)</span>. The time evolution operator ( U(t) ) is expressed as:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[
U(t) = e^{-i H t}
\]</div>
</div>
<p>For a time step of <span class="math notranslate nohighlight">\(0.1\)</span>, this operator becomes:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[
U(0.1) = e^{-i H \times 0.1}
\]</div>
</div>
<p>This calculated operator, <code class="docutils literal notranslate"><span class="pre">exp_hm</span></code>, will then be applied to simulate the quantum state’s evolution over the time step.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute the matrix exponential of the Hamiltonian for the time step of 0.1</span>
<span class="n">exp_hm</span> <span class="o">=</span> <span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">hm</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">exp_hm</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="circuit-construction-visualization">
<h3>Circuit Construction &amp; Visualization<a class="headerlink" href="#circuit-construction-visualization" title="Link to this heading">¶</a></h3>
<p>After calculating the time evolution operator, the next logical step is to integrate this operator into a quantum circuit. This allows for direct simulations or runs on quantum hardware or simulator. The <code class="docutils literal notranslate"><span class="pre">pytket</span></code> library provides tools to seamlessly achieve this. By wrapping our time evolution operator in a 2-qubit unitary box, we can then incorporate it into a quantum circuit, setting the stage for subsequent quantum simulations or analyses.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Creating a 2-qubit unitary box that represents the time evolution operator:</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.circuit</span><span class="w"> </span><span class="kn">import</span> <span class="n">Unitary2qBox</span>

<span class="n">u2box</span> <span class="o">=</span> <span class="n">Unitary2qBox</span><span class="p">(</span><span class="n">exp_hm</span><span class="p">)</span>

<span class="c1"># Initializing a 2-qubit circuit and embedding the time evolution operator into it:</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_unitary2qbox</span><span class="p">(</span><span class="n">u2box</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Retrieving the unitary matrix representation of the quantum circuit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>And obtaining the resulting quantum state after applying the circuit (from a default initial state):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="decomposition">
<h3>Decomposition<a class="headerlink" href="#decomposition" title="Link to this heading">¶</a></h3>
<p>Recognizing the constraints of real quantum hardware, the constructed circuit is decomposed into a set of elementary gates, ensuring its adaptability and compatibility. Specifically, in quantum circuit design, ‘boxed’ operations encapsulate complex actions. To standardize our circuit for broader applications, we’ll replace these boxed operations with sequences of elementary gates using pytket’s <code class="docutils literal notranslate"><span class="pre">DecomposeBoxes</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Importing the necessary tool for gate decomposition:</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.passes</span><span class="w"> </span><span class="kn">import</span> <span class="n">DecomposeBoxes</span>

<span class="c1"># Decomposing custom gates in the circuit to ensure compatibility with quantum hardware:</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can also visualize the quantum circuit using <code class="docutils literal notranslate"><span class="pre">pytket</span></code>’s rendering tool for Jupyter:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.circuit.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">render_circuit_jupyter</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="gate-analysis">
<h3>Gate Analysis<a class="headerlink" href="#gate-analysis" title="Link to this heading">¶</a></h3>
<p>The quantum circuit, post-decomposition, is dissected to provide a breakdown of its comprising gate types. This analysis gives valuable insights into the circuit’s intricacy and underlying structure.</p>
<p>Insights into the composition and complexity of our circuit can be obtained with the following command:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gate_counts</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The breakdown of gate occurrences in our quantum circuit is as follows:</p>
<ul class="simple">
<li><p>TK1 gates: 4</p></li>
<li><p>X gates: 2</p></li>
<li><p>TK2 gates: 1</p></li>
<li><p>Z gates: 2</p></li>
<li><p>Y gates: 2</p></li>
</ul>
<p>This summary serve as a valuable reference when we delve into the topics of recompilation and optimization for execution on H-series devices.</p>
<p><em>Note:</em> See <a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/optype.html">pytket.circuit.OpType</a> for the mathematical descriptions of TK1 and TK2 gates.</p>
</section>
<section id="time-evolution-circuits">
<h3>Time evolution circuits<a class="headerlink" href="#time-evolution-circuits" title="Link to this heading">¶</a></h3>
<p>The given Hamiltonian, <span class="math notranslate nohighlight">\(-i H t\)</span>, needs to be discretized for simulation on a quantum computer. This is where the Trotter-Suzuki approximation comes in handy, allowing us to approximate the time evolution operator <span class="math notranslate nohighlight">\(e^{-i H t}\)</span>.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[
e^{-i H t}=e^{-i\left(\frac{3}{8}\left(7-3 Z_0-Z_0 Z_1-3 Z_1\right)-\frac{x}{2}\left(3+Z_1\right) X_0-\frac{x}{2}\left(3+Z_0\right) X_1\right) t}
\]</div>
</div>
</section>
<section id="first-order-trotter-step">
<h3>First-Order Trotter Step<a class="headerlink" href="#first-order-trotter-step" title="Link to this heading">¶</a></h3>
<p>In the first-order Trotter step, the time evolution operator is approximated by
$<span class="math notranslate nohighlight">\(
\left(\prod_j e^{-i H_j \delta t} \right)^{N_t}
\)</span><span class="math notranslate nohighlight">\(
where \)</span>\delta t = \frac{t}{N_t}<span class="math notranslate nohighlight">\(. Here, \)</span> N_t <span class="math notranslate nohighlight">\( represents the number of Trotter steps, which is a parameter that determines the granularity of the time evolution approximation. A higher value of \)</span> N_t $ leads to a finer approximation of the time evolution operator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setting the maximum time for the simulation</span>
<span class="n">t_max</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Defining the number of Trotter steps for the approximation</span>
<span class="n">n_trotter_steps</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Calculating the time step for each Trotter step</span>
<span class="n">time_step</span> <span class="o">=</span> <span class="n">t_max</span> <span class="o">/</span> <span class="n">n_trotter_steps</span>

<span class="c1"># Creating a time line from 0 to t_max with equal intervals for each Trotter step</span>
<span class="n">time_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_trotter_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Printing the calculated time step</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time step: </span><span class="si">{</span><span class="n">time_step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Multiplying the Hamiltonian by the time step to get a slice of the Hamiltonian for each Trotter step</span>
<span class="n">hamiltonian_slice</span> <span class="o">=</span> <span class="n">hamiltonian</span> <span class="o">*</span> <span class="n">time_step</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">hamiltonian_slice</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>After slicing the Hamiltonian with the calculated <code class="docutils literal notranslate"><span class="pre">time_step</span></code>, we convert the <code class="docutils literal notranslate"><span class="pre">hamiltonian_slice</span></code> into a matrix format. This is done by first converting the Hamiltonian slice into a sparse matrix representation and then converting it to a dense matrix. The <code class="docutils literal notranslate"><span class="pre">.real</span></code> part extracts the real component of the matrix, which is necessary for some quantum computing simulations and visualizations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_slice</span><span class="o">.</span><span class="n">to_sparse_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="constructing-the-quantum-circuit-for-a-single-trotter-step">
<h3>Constructing the Quantum Circuit for a Single Trotter Step<a class="headerlink" href="#constructing-the-quantum-circuit-for-a-single-trotter-step" title="Link to this heading">¶</a></h3>
<p>After calculating the Hamiltonian slice for a single time step, we proceed to construct the quantum circuit that simulates this evolution. We use a utility <code class="docutils literal notranslate"><span class="pre">gen_term_sequence_circuit</span></code> which builds a circuit for us starting from the Hamiltonian we want in the exponent of a single Trotter step, and the initial reference state we want to start from. <a class="reference external" href="https://docs.quantinuum.com/tket/api-docs/utils.html#pytket.utils.gen_term_sequence_circuit">The pytket API documentation for gen_term_sequence_circuit</a> has more details.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># initializing a quantum circuit with two qubits</span>
<span class="n">initial_state</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># generate the circuit for the Trotter step</span>
<span class="n">trotter_step_circ</span> <span class="o">=</span> <span class="n">gen_term_sequence_circuit</span><span class="p">(</span><span class="n">hamiltonian_slice</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)</span>

<span class="c1"># visualize the circuit</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">trotter_step_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The circuit for a single Trotter step is composed of several <code class="docutils literal notranslate"><span class="pre">CircBox</span></code> components. The <code class="docutils literal notranslate"><span class="pre">get_commands()</span></code> method is used to explore the composition of the circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trotter_step_circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">CircBox</span></code> can be examined to reveal its internal structure, which typically consists of <code class="docutils literal notranslate"><span class="pre">PauliExpBox</span></code> boxes. We can get the individual <code class="docutils literal notranslate"><span class="pre">PauliExpBox</span></code> boxes from each <code class="docutils literal notranslate"><span class="pre">CircBox</span></code> in the circuit</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pauliexpbox0</span> <span class="o">=</span> <span class="n">trotter_step_circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">op</span>
<span class="n">box_circ</span> <span class="o">=</span> <span class="n">pauliexpbox0</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span>
<span class="n">box_circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In this nested <code class="docutils literal notranslate"><span class="pre">CircBox</span></code>  there are 3 <code class="docutils literal notranslate"><span class="pre">PauliExpBox</span></code>, of which only one acts on 2 qubits</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pauli_exp_box</span> <span class="o">=</span> <span class="n">box_circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">op</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">pauli_exp_box</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>For a more detailed analysis, we use the <code class="docutils literal notranslate"><span class="pre">DecomposeBoxes</span></code> pass from <code class="docutils literal notranslate"><span class="pre">pytket.passes</span></code>. This pass decomposes the circuit into fundamental quantum gates, allowing us to see the basic operations that constitute the Trotter step.</p>
<p>For one Trotter step:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_circuit</span> <span class="o">=</span> <span class="n">trotter_step_circ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_circuit</span><span class="p">)</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">test_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>and we can count the total number of gates</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gate_counts</span><span class="p">(</span><span class="n">test_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>or look at specific statistics of the circuit</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of gates = </span><span class="si">{</span><span class="n">test_circuit</span><span class="o">.</span><span class="n">n_gates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Circuit depth = </span><span class="si">{</span><span class="n">test_circuit</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of CX gates = </span><span class="si">{</span><span class="n">test_circuit</span><span class="o">.</span><span class="n">n_gates_of_type</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">CX</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="example-1-noiseless-emulation-of-a-circuit-for-one-trotter-step">
<h2>Example 1: Noiseless emulation of a circuit for one Trotter step<a class="headerlink" href="#example-1-noiseless-emulation-of-a-circuit-for-one-trotter-step" title="Link to this heading">¶</a></h2>
<p>We will first run a noiseless statevector emulation of the circuit on Quantinuum’s System Model H1 emulator. Quantinuum H-Series emulators model the physical and noise parameters of H-Series quantum computers. The emulators provide a way to turn the noise model off, while still modeling the physical properties of the device, such as ion transport.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.extensions.quantinuum</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantinuumBackend</span>

<span class="n">h_backend</span> <span class="o">=</span> <span class="n">QuantinuumBackend</span><span class="p">(</span><span class="s2">&quot;H1-2E&quot;</span><span class="p">)</span>  <span class="c1"># emulator</span>

<span class="n">h_backend</span><span class="o">.</span><span class="n">login</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="one-trotter-step">
<h3>One Trotter step<a class="headerlink" href="#one-trotter-step" title="Link to this heading">¶</a></h3>
<p>The Trotter step circuit can be enclosed in a <code class="docutils literal notranslate"><span class="pre">CircBox</span></code> and added to any circuit (this way we can add many steps in a sequence).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trotter_step_box</span> <span class="o">=</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">trotter_step_circ</span><span class="p">)</span>

<span class="c1"># define circuit for one Trotter step</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">trotter_step_box</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>When we compile the circuit for the backend, the <code class="docutils literal notranslate"><span class="pre">CircBox</span></code> nested boxes get decomposed into native gates. Each backend in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> has a list of default <em>passes</em> that are applied to it. They can be applied by calling <code class="docutils literal notranslate"><span class="pre">backend.get_compiled_circuit()</span></code> with different <code class="docutils literal notranslate"><span class="pre">optimisation_level</span></code> arguments (<a class="reference external" href="https://docs.quantinuum.com/tket/extensions/pytket-quantinuum/#default-compilation">the pytket-quantinuum docs</a> list the default values). Here we use the default <code class="docutils literal notranslate"><span class="pre">optimisation_level</span></code> for the <code class="docutils literal notranslate"><span class="pre">QuantinuumBackend</span></code>, which is 2.</p>
<p><em>Note:</em> The measurement operations from the <code class="docutils literal notranslate"><span class="pre">MeasurementSetup</span></code> object are appended to the numerical circuit. Once this step is complete, the circuit is ready for submission.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ_compiled</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">())</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Before submitting to the emulator, the total cost of running the set of circuits in H-System Quantum Credits (HQCs) can be checked beforehand.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_shots</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">cost</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">cost</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">,</span> <span class="n">syntax_checker</span><span class="o">=</span><span class="s2">&quot;H1-2SC&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost of experiment in HQCs:&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We submit the circuit to the Quantinuum H1-2 Emulator and make the emulation noiseless by passing the option <code class="docutils literal notranslate"><span class="pre">noisy_simulation=False</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">handle</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span>
    <span class="n">circ_compiled</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">,</span> <span class="n">noisy_simulation</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit_status</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">circuit_status</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit_status</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="example-2-noisy-emulation-on-the-system-model-h1-emulator-for-two-trotter-steps">
<h3>Example 2: Noisy emulation on the System Model H1 Emulator for two Trotter steps<a class="headerlink" href="#example-2-noisy-emulation-on-the-system-model-h1-emulator-for-two-trotter-steps" title="Link to this heading">¶</a></h3>
<p>Next we implement and run two Trotter steps on the H1-2E emulator with the emulator’s default noise model for two Trotter steps. The noise model mimicks the noise of the H1-2 quantum computer.</p>
<p>Let’s add two trotter steps to our circuit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># two steps</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">trotter_step_box</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">trotter_step_box</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ_compiled</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Our circuit has </span><span class="si">{</span><span class="n">circ_compiled</span><span class="o">.</span><span class="n">n_gates</span><span class="si">}</span><span class="s2"> quantum gates in total and an overall depth of </span><span class="si">{</span><span class="n">circ_compiled</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Of these gates </span><span class="si">{</span><span class="n">circ_compiled</span><span class="o">.</span><span class="n">n_gates_of_type</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">ZZPhase</span><span class="p">)</span><span class="si">}</span><span class="s2"> are two qubit gate, ZZPhase, counts.&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Before submitting to the emulator, the total cost of running the set of circuits in H-System Quantum Credits (HQCs) is checked beforehand.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_shots</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">cost</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">cost</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">,</span> <span class="n">syntax_checker</span><span class="o">=</span><span class="s2">&quot;H1-2SC&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost of experiment in HQCs:&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we run the circuits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">handle</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The status of the jobs can be checked with <code class="docutils literal notranslate"><span class="pre">ciruit_status</span></code> method. This method requires the <code class="docutils literal notranslate"><span class="pre">ResultHandle</span></code> to be passed as input. In this example, the job has completed and the results are reported as being ready to request.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit_status</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">circuit_status</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit_status</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Once a job’s status returns completed, results can be returned using the <code class="docutils literal notranslate"><span class="pre">get_result</span></code> function in conjunction with the <code class="docutils literal notranslate"><span class="pre">get_counts</span></code> call.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We note that when using <code class="docutils literal notranslate"><span class="pre">optimisation_level</span></code>equal to 0, we compile to the native gates of the H-Series without optimization and the number of 1- and 2-qubit gates is significantly larger than compared to the default <code class="docutils literal notranslate"><span class="pre">optimisation_level</span></code> of 2.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ_compiled_0</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">optimisation_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">gate_counts</span><span class="p">(</span><span class="n">circ_compiled_0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="example-3-symbolic-manipulation-in-quantum-circuit-simulation">
<h2>Example 3: Symbolic Manipulation in Quantum Circuit Simulation<a class="headerlink" href="#example-3-symbolic-manipulation-in-quantum-circuit-simulation" title="Link to this heading">¶</a></h2>
<p>In this section, we explore the use of symbolic manipulation for quantum circuit simulation, particularly focusing on the Trotter-Suzuki decomposition. We employ <code class="docutils literal notranslate"><span class="pre">sympy</span></code> for defining symbolic variables, which represent key parameters like coupling strengths and time steps in our quantum system. These symbols allow us to dynamically adjust our circuit parameters.</p>
<p>The symbols are related to the coupling and the time step.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="kn">import</span> <span class="n">symbols</span>

<span class="n">syms</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x dt&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We define various <code class="docutils literal notranslate"><span class="pre">QubitPauliString</span></code> objects to represent different Pauli operators acting on our qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zi</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>
<span class="n">iz</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>

<span class="n">xi</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">])</span>
<span class="n">ix</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">])</span>

<span class="n">zz</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>
<span class="n">xz</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">])</span>
<span class="n">zx</span> <span class="o">=</span> <span class="n">QubitPauliString</span><span class="p">([</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we define two dictionaries, <code class="docutils literal notranslate"><span class="pre">singles_syms</span></code> and <code class="docutils literal notranslate"><span class="pre">doubles_sym</span></code>, to represent parts of our Hamiltonian symbolically:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">singles_syms</span></code>: Maps 1-qubit Pauli strings to their coefficients. These terms, involving <code class="docutils literal notranslate"><span class="pre">Z</span></code> and <code class="docutils literal notranslate"><span class="pre">X</span></code> Pauli operators on individual qubits, reflect the linear contributions in the Hamiltonian. For example, terms like <code class="docutils literal notranslate"><span class="pre">zi</span></code> and <code class="docutils literal notranslate"><span class="pre">xi</span></code> are mapped to symbolic expressions involving <code class="docutils literal notranslate"><span class="pre">dt</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>, representing time step and coupling constants, respectively.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">doubles_sym</span></code>: Represents 2-qubit interaction terms. Here, combinations of <code class="docutils literal notranslate"><span class="pre">Z</span></code> and <code class="docutils literal notranslate"><span class="pre">X</span></code> operators on pairs of qubits are mapped to their corresponding coefficients. These terms capture the inter-qubit interactions in the Hamiltonian, with coefficients also expressed as functions of <code class="docutils literal notranslate"><span class="pre">dt</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">singles_syms</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">zi</span><span class="p">:</span> <span class="o">-</span><span class="mi">21</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">iz</span><span class="p">:</span> <span class="o">-</span><span class="mi">21</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">xi</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">ix</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">doubles_sym</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">zz</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">xz</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">zx</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">syms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>We now combine the 1-qubit and 2-qubit interaction terms defined in <code class="docutils literal notranslate"><span class="pre">singles_syms</span></code> and <code class="docutils literal notranslate"><span class="pre">doubles_sym</span></code> to form the first-order Trotterized Hamiltonian:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_trotterized</span> <span class="o">=</span> <span class="n">QubitPauliOperator</span><span class="p">({</span><span class="o">**</span><span class="n">singles_syms</span><span class="p">,</span> <span class="o">**</span><span class="n">doubles_sym</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_trotterized</span>
</pre></div>
</div>
</div>
</div>
<p>We can generate the circuit by using the same function as before</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">trotter_step_circ_symb</span> <span class="o">=</span> <span class="n">gen_term_sequence_circuit</span><span class="p">(</span><span class="n">hamiltonian_trotterized</span><span class="p">,</span> <span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">trotter_step_circ_symb</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Again, we can also decompose this symbolic circuit into basic gates and count these gates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.passes</span><span class="w"> </span><span class="kn">import</span> <span class="n">DecomposeBoxes</span>

<span class="n">test_circuit</span> <span class="o">=</span> <span class="n">trotter_step_circ_symb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_circuit</span><span class="p">)</span>
<span class="n">gate_counts</span><span class="p">(</span><span class="n">test_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">test_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can also make this symbolic circuit into a box that we can repeat for multiple Trotter steps:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trotter_step_box_symb</span> <span class="o">=</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">trotter_step_circ_symb</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This is a 2-step Trotter symbolic circuit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># two steps</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">trotter_step_box_symb</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">trotter_step_box_symb</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the final step of working with the symbolic circuit, we demonstrate how to substitute our symbolic parameters with actual numerical values:</p>
<ol class="arabic simple">
<li><p><strong>Defining Symbol Values</strong>: We first define a list <code class="docutils literal notranslate"><span class="pre">x_dt_values</span></code> containing the specific values for our symbols. In this example, <code class="docutils literal notranslate"><span class="pre">x</span></code> is set to 2.0 and <code class="docutils literal notranslate"><span class="pre">dt</span></code> to 0.01.</p></li>
<li><p><strong>Creating the Symbol-Value Map</strong>: Using <code class="docutils literal notranslate"><span class="pre">zip(syms,</span> <span class="pre">x_dt_values)</span></code>, we pair each symbol with its corresponding value, and then convert this pairing into a dictionary <code class="docutils literal notranslate"><span class="pre">sym_map</span></code>. This dictionary maps each symbolic variable to its numerical value.</p></li>
<li><p><strong>Applying Substitutions</strong>: We use <code class="docutils literal notranslate"><span class="pre">circ.symbol_substitution(sym_map)</span></code> to apply these substitutions to our circuit. This method replaces each occurrence of the symbolic variables in <code class="docutils literal notranslate"><span class="pre">circ</span></code> with their defined numerical values.</p></li>
</ol>
<p>Lastly, we render the updated circuit using <code class="docutils literal notranslate"><span class="pre">render_circuit_jupyter(circ)</span></code>. This visualization shows the circuit as it would be with the specific parameters applied.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
<span class="n">sym_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">x_dt_values</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sym_map</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span><span class="o">.</span><span class="n">symbol_substitution</span><span class="p">(</span><span class="n">sym_map</span><span class="p">)</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="implementation-of-the-su-2-5-plaquette-model-hamiltonian">
<h2>Implementation of the SU(2) 5-Plaquette Model Hamiltonian<a class="headerlink" href="#implementation-of-the-su-2-5-plaquette-model-hamiltonian" title="Link to this heading">¶</a></h2>
<p>Having explored the SU(2) 2-Plaquette Model, a foundational representation in lattice gauge theories, we now shift our focus to the more complex SU(2) 5-Plaquette Model. This transition marks a significant step towards understanding and simulating more intricate quantum systems. The 5-Plaquette Model, with its increased number of qubits, provides a richer and more detailed canvas to examine the dynamics of lattice gauge theories. This model’s Hamiltonian, characterized by its division into electric and magnetic components, captures the nuanced interactions within a lattice. Such a detailed representation is crucial for simulating real-world quantum phenomena and lays the groundwork for advanced quantum computing applications. By delving into the 5-Plaquette Model, we gain deeper insights into the behavior of complex quantum systems, paving the way for more accurate simulations and potentially groundbreaking discoveries in the realm of quantum physics. The following section presents the Hamiltonian of the SU(2) 5-Plaquette Model, implemented using <a class="reference external" href="https://qiskit.org"><code class="docutils literal notranslate"><span class="pre">Qiskit</span></code></a>, demonstrating how to interact with <code class="docutils literal notranslate"><span class="pre">Qiskit</span></code> code.</p>
<p>For the SU(2) 5-Plaquette Model, the 5-qubit Hamilatonian is given as follows</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
H= &amp; \frac{g^2}{2}\left(h_E+h_B\right) \\
h_E= &amp; \frac{3}{8}(3 N+1)-\frac{9}{8}\left(Z_0+Z_{N-1}\right)-\frac{3}{4} \sum_{n=1}^{N-2} Z_n \\
&amp; -\frac{3}{8} \sum_{n=0}^{N-2} Z_n Z_{n+1} \\
h_B= &amp; -\frac{x}{2}\left(3+Z_1\right) X_0-\frac{x}{2}\left(3+Z_{N-2}\right) X_{N-1} \\
&amp; -\frac{x}{8} \sum_{n=1}^{N-2}\left(9+3 Z_{n-1}+3 Z_{n+1}+Z_{n-1} Z_{n+1}\right) X_n
\end{aligned}
\end{split}\]</div>
</div>
<p>This model’s Hamiltonian is explicitly broken down into electric <span class="math notranslate nohighlight">\(h_E \)</span> and magnetic <span class="math notranslate nohighlight">\(h_B \)</span> components, each comprising various terms involving Pauli <span class="math notranslate nohighlight">\( \sigma_Z \)</span> and <span class="math notranslate nohighlight">\( \sigma_X \)</span> operators.</p>
<p>In this section, we construct the Hamiltonian for our quantum system using Qiskit’s <code class="docutils literal notranslate"><span class="pre">SparsePauliOp</span></code> build from a list of <code class="docutils literal notranslate"><span class="pre">Pauli</span></code> strings and their associated coefficients. The Hamiltonian is divided into two main components: the electric component (<code class="docutils literal notranslate"><span class="pre">h_e</span></code>) and the magnetic component (<code class="docutils literal notranslate"><span class="pre">h_b</span></code>). Each component is expressed as list of Pauli terms acting on the qubits and their respective coefficients. We use <code class="docutils literal notranslate"><span class="pre">SparsePauliOp</span></code> to write the Hamiltonian operator following the equations above quite literally (fix <span class="math notranslate nohighlight">\(x=2\)</span>):</p>
<ul class="simple">
<li><p>The electric component <code class="docutils literal notranslate"><span class="pre">h_e</span></code> includes terms involving <code class="docutils literal notranslate"><span class="pre">Z</span></code> Pauli operators, reflecting the electric interactions in the system.</p></li>
<li><p>The magnetic component <code class="docutils literal notranslate"><span class="pre">h_b</span></code> comprises terms with <code class="docutils literal notranslate"><span class="pre">X</span></code> and combined <code class="docutils literal notranslate"><span class="pre">XZ</span></code> Pauli operators, representing the magnetic interactions.</p></li>
</ul>
<p>The coefficients of each term are specific to our model, reflecting the strength of each interaction. We then combine these two components to form the complete Hamiltonian of the system, which is used for further analysis and simulation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">qiskit.quantum_info</span><span class="w"> </span><span class="kn">import</span> <span class="n">SparsePauliOp</span>

<span class="n">h_e</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;ZIIII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIIIZ&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IZIII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIZII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIIZI&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;ZZIII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IZZII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIZZI&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIIZZ&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">8</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">h_b</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;XIIII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;XZIII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIIIX&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIIZX&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IXIII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;ZXIII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IXZII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;ZXZII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIXII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IZXII&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIXZI&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IZXZI&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIIXI&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">9.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIZXI&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIIXZ&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;IIZXZ&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">SparsePauliOp</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">h_e</span> <span class="o">+</span> <span class="n">h_b</span><span class="p">)</span>

<span class="n">hamiltonian</span>
</pre></div>
</div>
</div>
</div>
<p>A dense (or sparse) matrix representation of the operator can be accessed directly with the method <code class="docutils literal notranslate"><span class="pre">SparsePauliOp.to_matrix()</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As a first step we can compute the ground state of the Hamiltonian by diagonalizing and extracting the lowest eigenvalue. There are many ways to do this but one can pass the (sparse) matrix obtained from <code class="docutils literal notranslate"><span class="pre">SparsePauliOp</span></code> representing our Hamiltonian to a numerical eigensolver</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">eigs</span>

<span class="n">vals</span><span class="p">,</span> <span class="n">vecs</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Energy of the ground state </span><span class="si">{</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In this section, we build utility functions to translate <code class="docutils literal notranslate"><span class="pre">Qiskit</span></code>’s Hamiltonian representation into the <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> format used by <code class="docutils literal notranslate"><span class="pre">pytket</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qps_from_sparsepauliop</span></code>: This function converts a tensor of Pauli operators from <code class="docutils literal notranslate"><span class="pre">SparsePauliOp</span></code> format to pytket’s <code class="docutils literal notranslate"><span class="pre">QubitPauliString</span></code>. It iterates over qubit indices and corresponding Pauli operators, mapping them to the <code class="docutils literal notranslate"><span class="pre">pytket</span></code> equivalent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qpo_from_sparsepauliop</span></code>: This function takes an <code class="docutils literal notranslate"><span class="pre">Qiskit</span></code> <code class="docutils literal notranslate"><span class="pre">SparsePauliOp</span></code> and converts it into a <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code>. It processes each term in the <code class="docutils literal notranslate"><span class="pre">Qiskit</span></code> operator, using <code class="docutils literal notranslate"><span class="pre">qps_from_sparsepauliop</span></code> for conversion, and associates it with the corresponding coefficient.</p></li>
</ul>
<p>Finally, we apply <code class="docutils literal notranslate"><span class="pre">qpo_from_sparsepauliop</span></code> to our previously defined Hamiltonian and print the result. This step confirms that the Hamiltonian is correctly converted into the format required by pytket for further quantum computations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.pauli</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pauli</span><span class="p">,</span> <span class="n">QubitPauliString</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitPauliOperator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytket</span><span class="w"> </span><span class="kn">import</span> <span class="n">Qubit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">pauli_sym</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">qps_from_sparsepauliop</span><span class="p">(</span><span class="n">paulis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert SparsePauliOp tensor of Paulis to pytket QubitPauliString.&quot;&quot;&quot;</span>
    <span class="n">qlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paulis</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
            <span class="n">qlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
            <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pauli_sym</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">QubitPauliString</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">plist</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">qpo_from_sparsepauliop</span><span class="p">(</span><span class="n">sp_op</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert SparsePauliOp QubitOperator to pytket QubitPauliOperator.&quot;&quot;&quot;</span>
    <span class="n">tk_op</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">sp_op</span><span class="o">.</span><span class="n">to_list</span><span class="p">():</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">qps_from_sparsepauliop</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="n">tk_op</span><span class="p">[</span><span class="n">string</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
    <span class="k">return</span> <span class="n">QubitPauliOperator</span><span class="p">(</span><span class="n">tk_op</span><span class="p">)</span>


<span class="n">hamiltonian_op</span> <span class="o">=</span> <span class="n">qpo_from_sparsepauliop</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hamiltonian_op</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The next line of code converts the <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> representation of the Hamiltonian, obtained in the previous step, into a dense matrix format. The <code class="docutils literal notranslate"><span class="pre">to_sparse_matrix()</span></code> method first transforms the Hamiltonian into a sparse matrix. We then use <code class="docutils literal notranslate"><span class="pre">todense()</span></code> to convert this sparse matrix into a regular, dense matrix. This dense matrix representation is useful for certain types of numerical analyses and visual inspections of the Hamiltonian structure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_op</span><span class="o">.</span><span class="n">to_sparse_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
    <span class="n">hamiltonian_op</span><span class="o">.</span><span class="n">to_sparse_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We now proceed with the Trotter-Suzuki decomposition to approximate the time-evolution operator of the Hamiltonian in quantum simulations as we did above.</p>
<p><em>Note:</em> <code class="docutils literal notranslate"><span class="pre">rescaling_factor_from_pytket</span> <span class="pre">=</span> <span class="pre">np.pi/2</span></code> is defined for aligning simulation results with exact theoretical predictions. This factor compensates for an additional π/2 factor introduced by <code class="docutils literal notranslate"><span class="pre">gen_term_sequence_circuit</span></code> in <code class="docutils literal notranslate"><span class="pre">pytket</span></code>, which affects the time evolution steps. When comparing with exact results, divide the time step (<span class="math notranslate nohighlight">\(\delta t\)</span>) by this rescaling factor to account for this discrepancy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># rescaling_factor_from_pytket = np.pi/2  ## use it to divide \deltat in case you want to compare with the exact results: gen_term_sequence adds Pauliexpbox with an extrat pi/2 factor</span>
<span class="n">t_max</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">n_trotter_steps</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">time_step</span> <span class="o">=</span> <span class="n">t_max</span> <span class="o">/</span> <span class="n">n_trotter_steps</span>
<span class="n">time_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_trotter_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time step: </span><span class="si">{</span><span class="n">time_step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">hamiltonian_slice</span> <span class="o">=</span> <span class="n">hamiltonian_op</span> <span class="o">*</span> <span class="n">time_step</span>
</pre></div>
</div>
</div>
</div>
<p>Next we construct the corresponding five-qubit circuit for two Trotter steps. A product of exponential of Pauli strings can be automatically generated by <code class="docutils literal notranslate"><span class="pre">pytket</span></code> using <code class="docutils literal notranslate"><span class="pre">gen_term_sequence_circuits</span></code>, including aggregating mutually commuting terms into groups.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">trotter_step_circ</span> <span class="o">=</span> <span class="n">gen_term_sequence_circuit</span><span class="p">(</span><span class="n">hamiltonian_slice</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The Trotter step circuit can be enclosed in a <code class="docutils literal notranslate"><span class="pre">CircBox</span></code> and added to any circuit (this way we can add many steps in a sequence)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trotter_step_box</span> <span class="o">=</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">trotter_step_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now one Trotter step is a single box, and we can simply stack boxes to create circuits for more Trotter steps</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># two steps</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">trotter_step_box</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">trotter_step_box</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.circuit.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">render_circuit_jupyter</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we sign into the Quantinuum Backend we will submit to, H1-2E, and compile the circuit for the backend.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.extensions.quantinuum</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantinuumBackend</span>

<span class="n">h_backend</span> <span class="o">=</span> <span class="n">QuantinuumBackend</span><span class="p">(</span><span class="s2">&quot;H1-2E&quot;</span><span class="p">)</span>  <span class="c1"># emulator</span>

<span class="n">h_backend</span><span class="o">.</span><span class="n">login</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ_compiled</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">())</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can look at the statistics of the circuit before running it on the emulator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gate_counts</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we run the circuit on the Quantinuum H1-2 Emulator. Before submitting to the emulator, the total cost of running the circuit should be checked beforehand.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_shots</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">cost</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">cost</span><span class="p">(</span><span class="n">circ_compiled</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">,</span> <span class="n">syntax_checker</span><span class="o">=</span><span class="s2">&quot;H1-2SC&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost of experiment in HQCs:&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we run the circuit with the noise model turned on</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">handle</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span>
    <span class="n">circ_compiled</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">,</span> <span class="n">noisy_simulation</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit_status</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">circuit_status</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit_status</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can also plot the result using the following helper code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">plot_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
    <span class="n">counts_record</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;State&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="s2">&quot;Count&quot;</span><span class="p">:</span> <span class="n">count</span><span class="p">}</span> <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">]</span>
    <span class="n">count_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">counts_record</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">catplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;State&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;Count&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">count_df</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And compare our results to the noiseless emulation, we see that our emulator results match the noiseless simulation closely.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noiseless_handle</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span>
    <span class="n">circ_compiled</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">,</span> <span class="n">noisy_simulation</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">noiseless_result</span> <span class="o">=</span> <span class="n">h_backend</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">noiseless_handle</span><span class="p">)</span>
<span class="n">noiseless_counts</span> <span class="o">=</span> <span class="n">noiseless_result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_counts</span><span class="p">(</span><span class="n">noiseless_counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>One can also run the noiseless simulation using the Qiskit <code class="docutils literal notranslate"><span class="pre">Aer</span></code> backend directly from <code class="docutils literal notranslate"><span class="pre">pytket</span></code> using our <code class="docutils literal notranslate"><span class="pre">pytket-qiskit</span></code> extension:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pytket.extensions.qiskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">AerBackend</span>

<span class="c1"># define Aer backend</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">AerBackend</span><span class="p">()</span>
<span class="c1"># compile circuit as usual, but now for the new backend</span>
<span class="n">compiled_circ</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># submit and run the job: this runs locally and not in the cloud</span>
<span class="n">handle</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span><span class="n">compiled_circ</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="c1"># print(counts)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="definitions">
<span id="hep-definitions"></span><h2>Definitions<a class="headerlink" href="#definitions" title="Link to this heading">¶</a></h2>
<p>Definitions for the use case context in this article.</p>
<ul class="simple">
<li><p><em>Quantum Field Theory (QFT):</em> a mathematical and conceuptual framework in theoretical physics extending quantum mechanics, which deals with particles, over to fields, which are systems with infinite number of degrees of freedom. It is used in particle physics to construct physical models of subatomic particles and condensed matter physics to construct models of quasiparticles. Difficult due to the infinite number of degrees of freedom.</p></li>
<li><p><em>Lattice Gauge Theory (LGT):</em> a mathematical framework in QFT. Rather than having infinite degrees of freedom, space and time are discretized to a very large number of degrees of freedom, enabling its study on computers.</p></li>
<li><p><em>Perturbation Theory:</em> a method for finding an approximate solutions to a problem, by starting from the exact solution of a related, simpler problem</p></li>
<li><p><em>Quantum Chromodynamics:</em> theory that describes the action of the strong nuclear force, the fundamental interaction between subatomic particles of matter inside protons and neutrons.</p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="Quantinuum_leakage_detection.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Automatic Leakage Error Detection</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="Quantinuum_chemistry_chemically_aware_ucc.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Quantum Chemistry Calculations with Arbitrary Angle 2-Qubit Gates</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
              Copyright &#169; 2024 Quantinuum Ltd. All rights reserved.
            </div>
            <div class="terms" style="display:flex; gap:0.5rem; align-items:center; margin: 0.25rem 0rem;">
              <a href="https://www.quantinuum.com/privacy-statement" target="_blank">Privacy Statement</a>
              <div role="separator">/</div>
              <a href="https://www.quantinuum.com/cookie-notice" target="_blank">Cookie Notice</a>
              <div role="separator">/</div>
              <a href="https://www.quantinuum.com/terms-conditions" target="_blank">Terms and Conditions</a>
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">High Energy Physics: Implementing <span class="math notranslate nohighlight">\(SU(2)\)</span> Lattice Gauge Theory Trotter Circuits</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#setup">Setup</a></li>
<li><a class="reference internal" href="#hamiltonian-formulation">Hamiltonian Formulation</a></li>
<li><a class="reference internal" href="#su-2-2-plaquette-model-hamiltonian">SU(2) 2-Plaquette Model Hamiltonian</a></li>
<li><a class="reference internal" href="#implementation-of-the-su-2-2-plaquette-model-hamiltonian">Implementation of the SU(2) 2-Plaquette Model Hamiltonian</a><ul>
<li><a class="reference internal" href="#matrix-formulation">Matrix Formulation</a></li>
<li><a class="reference internal" href="#time-evolution-operator">Time Evolution Operator</a></li>
<li><a class="reference internal" href="#circuit-construction-visualization">Circuit Construction &amp; Visualization</a></li>
<li><a class="reference internal" href="#decomposition">Decomposition</a></li>
<li><a class="reference internal" href="#gate-analysis">Gate Analysis</a></li>
<li><a class="reference internal" href="#time-evolution-circuits">Time evolution circuits</a></li>
<li><a class="reference internal" href="#first-order-trotter-step">First-Order Trotter Step</a></li>
<li><a class="reference internal" href="#constructing-the-quantum-circuit-for-a-single-trotter-step">Constructing the Quantum Circuit for a Single Trotter Step</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-1-noiseless-emulation-of-a-circuit-for-one-trotter-step">Example 1: Noiseless emulation of a circuit for one Trotter step</a><ul>
<li><a class="reference internal" href="#one-trotter-step">One Trotter step</a></li>
<li><a class="reference internal" href="#example-2-noisy-emulation-on-the-system-model-h1-emulator-for-two-trotter-steps">Example 2: Noisy emulation on the System Model H1 Emulator for two Trotter steps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-3-symbolic-manipulation-in-quantum-circuit-simulation">Example 3: Symbolic Manipulation in Quantum Circuit Simulation</a></li>
<li><a class="reference internal" href="#implementation-of-the-su-2-5-plaquette-model-hamiltonian">Implementation of the SU(2) 5-Plaquette Model Hamiltonian</a></li>
<li><a class="reference internal" href="#definitions">Definitions</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=17c178fb"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>